# 笛语 (Diyu) Agent -- 系统定位与架构总览

> **文档状态:** 架构定稿（基于 v3.0 + 两套 SSOT 修正 + Type A 解耦 + 契约体系完善）
> **版本:** v3.6
> **创建日期:** 2026-02-07
> **核心定位:** 以对话 Agent 为内核、双 SSOT 为基座、技能可插拔的智能工作助理平台

---

## 变更记录

| 版本 | 日期 | 变更内容 |
|------|------|---------|
| v2.0 | 2026-02-07 | 全新架构设计，六层架构 + 组织模型 |
| v2.1 | 2026-02-07 | 新增 Tool 层、LLM Gateway、三核心 Skill 细化 |
| v3.0 | 2026-02-07 | 架构根本性重构：对话 Agent 上升为系统内核；Knowledge 层重新定义；Skill/Tool 可插拔 |
| v3.1 | 2026-02-07 | 双 SSOT 修正：Memory Core(硬依赖) 与 Knowledge Stores(软依赖) 平行不从属；同心圆架构替换为双核拓扑；三条写入管线分离；隐私硬边界确立 |
| **v3.1.1** | **2026-02-07** | **Type A 接口级完全解耦裁决；原则 10 渐进式组合；Day 1 必须定义 6 个 Port 接口；风险重评估** |
| **v3.2** | **2026-02-07** | **三大核心场景锚点(Section 3); 降级矩阵扩展错误分类与幂等约定(Section 11); Context Assembler 性能策略(01 Section 4.4); Memory Core HA(07 Section 6); FK 一致性保障(02 Section 7.3); Promotion Pipeline 错误处理(02 Section 7.2); 事件可靠性分级(06 Section 6); Gateway 限流/WebSocket/内容安全(05 Section 6-8); ADR-024~028; 附录C废弃** |
| **v3.2.1** | **2026-02-08** | **LAW/RULE/BRIDGE 约束分类(06 Section 1.6); RBAC 扩展 11 列+权限码映射(06 Section 1.3); API 分区规则(05 Section 4.1); 外部消费者 Step 8/9(Section 12.2); ADR-029~030** |
| **v3.3** | **2026-02-08** | **架构元模型显式化: 三级独立性梯度(Section 7.4); 跨层业务闭环地图 5条Loop(Section 7.5); 语义契约 v1: KnowledgeBundle(02 Section 5.4.1)/MemoryItem(01 Section 2.3.1)/OrgContext(05 Section 4.2); 基线修复: 认证序列(05 Section 4.1)/Port数量/术语统一; ADR-031~033** |
| **v3.3.1** | **2026-02-08** | **Port 演进策略: 变更分类+Expand-Contract迁移+Deprecation规则(Section 12.5); 契约测试策略: 三层测试+CI集成(Section 12.6); 契约索引表(08 附录G); ADR-034** |
| **v3.3.2** | **2026-02-08** | **LAW 约束参数化评估(06 Section 1.6.1): 3项确认为真正不变量、1项保持LAW但预留扩展路径、2项可参数化但需V2规划** |
| **v3.5.1** | **2026-02-09** | **CE (Context Engineering) 优化落盘: pgvector 默认启用(ADR-042, 01 Section 3.2.1); Hybrid Retrieval+RRF(01 Section 4.1 Step 1); Multi-Signal Reranking(01 Section 4.1 Step 1.3); Query Rewriting(01 Section 4.1 Step 0.5); 后处理闭环(01 Section 4.1.1); Evolution Pipeline CE 增强(01 Section 2.3.0.1); confidence_effective 衰减计算(01 Section 2.3.2.4); injection_receipt v3.1 扩展(06 Section 9); memory_items 增加 embedding+last_validated_at 列(06 Section 9)** |
| **v3.6** | **2026-02-11** | **多模态能力架构落盘(源文档: docs/reviews/后端多模态完善补全.md): ContentBlock Schema v1.1(ADR-043); 双域媒体存储 personal/enterprise(ADR-044); 三步上传协议(ADR-045); LLMCallPort Expand content_parts(ADR-046); Tool独立计费(ADR-047); 媒体删除完整性(ADR-048); Tier命名修正(ADR-049); 版本号三层分离(ADR-050); 媒体安全状态机(ADR-051); Checksum规范(ADR-052); ObjectStoragePort(v3.6 Extension Port); 9文档全量升级v3.6** |

---

## 1. 一句话定义

笛语是一个**以对话 Agent 为内核、以双 SSOT（私人记忆 + 企业知识）为基座、以可插拔技能为四肢**的多层级组织智能工作助理平台。

## 2. 核心比喻

```
笛语 = 大脑(含私人记忆) + 大脑皮层(企业知识) + 可更换的四肢

大脑 + 私人记忆（Brain + Memory Core, 硬依赖）:
  能听、能说、能理解、能记忆、越聊越懂你
  即使没有任何四肢和大脑皮层，大脑仍然完整运转
  私人记忆是大脑的一部分，不可分割

大脑皮层（Knowledge Stores, 软依赖可插拔）:
  企业知识资产：SKU/品类/搭配关系/品牌规范/SOP
  图谱是骨架（谁和谁什么关系），向量是血肉（具体内容的含义）
  两者通过 FK 互相引用，共同构成企业知识世界
  拔掉大脑皮层，大脑仍能对话和记忆，只是丧失领域知识深度

可更换的四肢（Skill + Tool）:
  大脑需要"做事"时，伸出对应的手
  内容生产是一只手，陈列搭配是一只手，数据分析是一只手
  装上一只新手 = 注册一个新 Skill
  拆掉一只手 不等于 大脑受损
```

## 3. 当前阶段核心场景

> 笛语 v1 聚焦以下三大场景做深做透，作为架构验收与 Skill 优先级的锚点。

### 场景 1: 对话聊天 -- "越聊越懂你"

```
承载层: Brain 5 大固有能力（对话引擎 / 意图理解 / 记忆引擎 / 角色适配 / 技能调度）
核心价值:
+-- Memory Engine 驱动个人记忆持续进化（偏好 / 行为模式 / 洞察）
+-- Role Adaptation 按组织层级 + 角色 + 个人偏好调整对话风格
+-- 负反馈熔断保证记忆质量不退化
+-- 无需任何 Skill 或 Knowledge Stores 即可完整运行（内核自足）
```

### 场景 2: 内容生产

```
承载层: ContentWriterSkill + Knowledge Stores + Tool
核心价值:
+-- 三级渠道架构（brand -> region -> store）下的分级内容管控
+-- 多人设: 品牌官方 / 个人 VLOG / 职场成长 / 家庭教育 / 本地生活 / 数字游民等
+-- 内容矩阵: 产品文案 / 穿搭教程 / 产品评测 / 旅游穿搭 / 门店 VLOG / 赛博朋克等
+-- 多平台适配: 小红书 / 抖音 / 微信公众号 / 门店日常 / 培训内容
+-- 多级合规: 系统自动 -> 区域审核 -> 总部审核
```

### 场景 3: 陈列搭配知识体系

```
承载层: MerchandisingSkill + Knowledge Stores (StylingRule 图谱) + Tool
核心价值:
+-- 搭配规则图谱（StylingRule + COMPATIBLE_WITH 关系 + 兼容度评分）
+-- 面向省级代理商的搭配培训内容生成
+-- 面向加盟终端门店的库存陈列搭配实时助手
+-- 库存感知推荐（AVAILABLE_AT + stock_quantity 实时关联）
+-- 内部培训材料自动生成（TrainingMaterial 实体）
```

### 扩展原则

```
扩展方式: 新场景 = 新 Skill + 注册实体类型 + 注册 Resolver Profile
核心约束:
+-- 乐高积木、可插拔式 -- Skill 注册即用，拔掉不影响内核
+-- 始终向后兼容 -- 新 Skill 不影响已有 Skill 和 Brain 功能
+-- 后续可扩展方向（举例，不穷举）:
      餐饮 / 美妆 / 教育 / MCN 机构 / 办公助手 / 数据分析 /
      供应链管理 / 服装设计创意助手 / 服装版型创意助手 /
      企业 ERP 集成 / 直播电商对接 / 全国门店库存实时管理调配等
+-- 每个扩展方向 = 一个或多个新 Skill，核心架构不变
```

---

## 4. 核心理念

> 笛语不是大语言模型，而是大语言模型之上的**智能外壳（Intelligent Shell）**。

- **对话为基座:** 用户的一切交互都通过对话进入，系统首先是一个越聊越懂你的 Agent
- **双 SSOT 并行:** Memory Core（私人记忆）和 Knowledge Stores（企业知识）是两套平行的数据真值源，不从属
- **隐私硬边界:** Knowledge Stores 永远不直接读 Memory Core
- **技能可插拔:** 新增能力 = 注册新积木，移除能力 = 拔掉积木，内核不受影响
- **组织可适应:** 同一品牌下不同层级的用户，获得与其角色匹配的交互方式和内容管控

## 5. 设计原则

1. **内核自足。** Brain + Memory Core 不依赖任何 Skill 或 Knowledge Stores 即可完整运行。
2. **双 SSOT 平行。** Memory Core 管私人记忆（硬依赖），Knowledge Stores 管企业资产（软依赖），两者不从属。
3. **隐私硬边界。** Knowledge Stores 永远不读 Memory Core。仅 Context Assembler（Brain 内部组件）可同时读取两者。
4. **扩展通过注册，不通过修改。** 新增能力 = 注册新 Skill + 注册新实体类型到 Knowledge Stores，核心代码零修改。
5. **图谱是骨架，向量是血肉。** 图谱存结构和关系，向量存语义和内容，两者通过 FK 互联互通。
6. **知识向下继承，权限向上收敛。** 上级知识自动对下级生效；下级操作权限由上级管控策略决定。
7. **闭环学习。** 对话产生观察 -> 分析进化 -> 沉淀为记忆/知识 -> 反哺下一次对话。
8. **三条写入管线分离。** Memory 自动写、Knowledge 受控写、Promotion 跨域审批写，各走各的。
9. **核心自有，基础设施借力。** 内核（Brain/Memory Core/Knowledge Stores/Resolver）自建；通用能力借助成熟开源组件。
10. **渐进式组合（Incremental Composition）。** 系统按 Brain -> Tool -> Skill -> Knowledge -> Gateway -> Infrastructure -> Deployment 的顺序逐层接入，每层接入时对已有层零修改。验证标准：第 N 层加入后，前 N-1 层的全部测试仍然 PASS。

## 6. 目标用户

> **[裁决]** 笛语定位为 To B 产品，服务对象为企业客户及其下辖员工和个体工商户。

| 用户类型 | 身份特征 | 认证方式 |
|---------|---------|---------|
| 品牌总部员工 | W2 员工，归属企业组织 | 企业 SSO / OIDC（后期对接） |
| 区域代理人员 | 代理公司员工 | 邮箱/手机号注册，邀请制 |
| 门店个体工商户 | 加盟商/店长/店员 | 手机号注册，邀请制 |
| 平台运维人员 | 笛语内部 | 内部认证 |

---

## 7. 架构拓扑

> **[v3.1 根本变更]** 放弃同心圆架构，改为**双核拓扑**——Brain + Memory Core 作为核心对，Knowledge Stores 作为可插拔大脑皮层，两者通过 Context Assembler 桥接。

> **外部消费者（不属于系统内部层）:** Frontend UI 和 Admin Console 是系统的外部消费者，通过 Gateway 暴露的 API 与系统交互。它们消费系统能力，但不改变系统内部架构。详见 Section 12.2 Step 8/9。

```
+-------------------------------------------------------------------+
|                     笛语 (Diyu) Agent                              |
|                                                                    |
|  +----- 可插拔四肢 (Skill + Tool) --------------------------------+|
|  |                                                                ||
|  |  [ContentWriter] [Merchandising] [DataAnalysis] ...            ||
|  |       |               |               |                       ||
|  |  [LLMCall]  [WebSearch]  [ImageGen]  [CodeBox]  ...            ||
|  |                                                                ||
|  +--------|-------------|-------------|---------------------------+|
|            |             |             |                           |
|            v             v             v                           |
|  +----------------------------------------------------------+     |
|  |              Context Assembler (Brain 内部组件)            |     |
|  |       唯一同时读取两个 SSOT 的组件 / 隐私硬边界           |     |
|  +----------+------------------------------+-----------------+     |
|             |                              |                       |
|     [硬依赖,必须]                    [软依赖,可插拔]                |
|             |                              |                       |
|  +----------v-----------+    +-------------v-------------------+   |
|  | SSOT-A: Memory Core  |    | SSOT-B: Knowledge Stores       |   |
|  | (Brain 的心脏)        |    | (可插拔大脑皮层)                |   |
|  |                      |    |                                 |   |
|  | - 对话事件流          |    |  Neo4j <-- FK 联动 --> Qdrant   |   |
|  | - 个人偏好/行为模式   |    | (骨架:结构关系) (血肉:语义内容) |   |
|  | - 会话摘要            |    |                                 |   |
|  | - 回执/tombstone      |    |  企业资产: SKU/搭配/规范/SOP    |   |
|  |                      |    |  Resolver + 实体类型注册         |   |
|  | 存储: PG/SQLite WAL  |    |  存储: Neo4j + Qdrant            |   |
|  | 所有者: 个人用户      |    |  所有者: 组织                    |   |
|  +----------------------+    +---------------------------------+   |
|                                                                    |
|  +----------------------------------------------------------+     |
|  |  Brain (对话 Agent 内核)                                   |     |
|  |  对话引擎 / 意图理解 / 记忆引擎 / 角色适配 / 技能调度     |     |
|  +----------------------------------------------------------+     |
|                                                                    |
|  +----------------------------------------------------------+     |
|  |  Gateway -- 协议适配 / 认证鉴权 / 组织上下文               |     |
|  +----------------------------------------------------------+     |
|  +----------------------------------------------------------+     |
|  |  基础设施 -- LLM Gateway / PG / Redis / Langfuse          |     |
|  |  Token Billing / Audit / Event Bus / 组织模型              |     |
|  +----------------------------------------------------------+     |
|  +----------------------------------------------------------+     |
|  |  部署 -- SaaS / 私有 / 混合                                |     |
|  +----------------------------------------------------------+     |
+-------------------------------------------------------------------+
```

### 7.1 双 SSOT 特征对比

| 维度 | SSOT-A: Memory Core | SSOT-B: Knowledge Stores |
|------|--------------------|-----------------------|
| 管什么 | 对话事件流、个人偏好/行为模式、会话摘要、回执、删除权(tombstone) | SKU/品类/属性网络、搭配关系、品牌规范、组织结构、SOP、案例库 |
| 数据来源 | 对话交互自动提取（Observer/Analyzer/Evolver） | Admin API、ERP/PIM 导入、批量解析、Skill 生成、Promotion 审批后提案 |
| 所有者 | 个人用户（tenant 下的 user） | 组织（品牌/区域/门店/平台） |
| 特征 | 高频、时序、可进化、强隐私 | 结构关系密集、规模大、变更需审计、继承链与权限严格 |
| 存储 | PostgreSQL/SQLite WAL（事务化，append-mostly 友好）+ pgvector 扩展（个人记忆语义检索，见 01 Section 3.2.1 / ADR-042） | Neo4j（结构真值）+ Qdrant（语义资产真值，含 FK 联动） |
| 依赖性 | **硬依赖**（挂了 = 系统不可用） | **软依赖**（拔了 = 降级运行） |

### 7.2 Scope 模型（两套，不混装）

**Memory Core scope（只管记忆）:**

| Scope | 含义 | 持久化 |
|-------|------|--------|
| session | 会话实时上下文 | 内存；会话结束归档为事件 |
| personal | 个人偏好/模式/摘要 | 持久化到 PG/SQLite |

**Knowledge Stores scope（只管企业资产）:**

| Scope | 含义 | 继承 |
|-------|------|------|
| store | 门店级 | 继承 region/brand/global |
| region | 区域级 | 继承 brand/global |
| brand | 品牌级 | 继承 global |
| global(platform) | 平台级 | 根 |

### 7.3 内核自足性验证

```
测试: 拔掉所有 Skill、Tool(仅保留 LLMCall)、Knowledge Stores，系统应该:

[PASS] 能接收用户消息并回复（对话引擎）
[PASS] 能理解用户意图并给出建议（意图理解）
[PASS] 能记住之前聊过什么（Memory Core session scope）
[PASS] 能积累对用户的理解（Memory Core personal scope）
[PASS] 能告诉用户"我目前没有内容生产的能力"（优雅降级）

[FAIL] 不能生产营销内容（需要 ContentWriterSkill）
[FAIL] 不能推荐搭配方案（需要 MerchandisingSkill）
[FAIL] 不能联网搜索最新信息（需要 WebSearch Tool）
[FAIL] 不能基于企业知识回答领域问题（需要 Knowledge Stores）
[DEGRADED] 角色适配退化为默认规则（无法读取 Knowledge 中的 RoleAdaptationRule）
```

### 7.4 架构元模型: 层级独立性梯度

> **[v3.3 新增]** 系统不是 7 个均匀独立的模块。各层的独立性有明确梯度，影响替换成本和演进自由度。

```
独立性梯度（从低到高）:

Level 0: 不可分核心对（Core Pair）
  Brain + Memory Core
  +-- 硬依赖，拆分 = 系统不可用
  +-- 共享 MemoryCorePort 契约，但语义深度耦合
  +-- 替换成本: 极高（等价于重建系统内核）
  +-- 验证闭环: Brain 能对话 + 记忆 + 进化 = 内核自足

Level 1: Port 耦合功能层（Functional Layers）
  Knowledge Stores / Skill 层 / Tool 层 / Gateway 层
  +-- 通过 Port 接口与核心对交互，契约明确
  +-- 可独立替换实现（只要 Port 签名 + 语义契约兼容）
  +-- 替换成本: 中（需满足 Port 契约 + 语义契约）
  +-- 验证闭环: 各层 Port Stub 可通过 -> 该层可独立测试

Level 2: 可插拔环境层（Environment Layer）
  基础设施层 / 部署层
  +-- 提供运行时环境，不参与业务语义
  +-- 可通过配置/适配器切换（PG->SQLite, SaaS->私有部署）
  +-- 替换成本: 低（配置级或适配器级变更）
  +-- 验证闭环: 基础设施健康检查 + 部署冒烟测试
```

```
"层独立" 的准确含义:

不是: 各层互不相关，可以任意拆装
而是: 各层通过 Port 契约解耦，在契约兼容的前提下可独立演进

"闭环" 存在两个层面:
  1. 工程闭环（层内）: 每层可独立开发、测试、部署
  2. 业务闭环（跨层）: 用户价值由多层协作的 Loop 交付（见 Section 7.5）

两层闭环的关系: 工程闭环保障各层可独立迭代；业务闭环保障系统整体交付用户价值。
Port 契约是两层闭环的连接点。
```

### 7.5 跨层业务闭环地图

> **[v3.3 新增]** 用户价值由以下 5 条跨层 Loop 协作交付。每条 Loop 跨越多个层级，依赖 Port 契约和语义契约连接。任何一条 Loop 断裂，对应的业务能力降级。

```
Loop A: 学习进化闭环
  触发: 对话交互积累
  路径: Brain 记忆引擎 -> Memory Core(观察/分析/进化)
        -> 达到阈值 -> Promotion Pipeline -> Knowledge Stores
  涉及层: Brain + Memory Core + Knowledge Stores
  涉及契约: MemoryCorePort, EvolutionProposal schema, Knowledge Write API
  完成条件: 个人观察 -> 组织知识沉淀成功
  断裂影响: 系统仍可对话和记忆，但无法将个人洞察升级为组织知识
  v3.6 多模态影响 [Medium]: Memory Core 需存储多模态 conversation_events (ContentBlock);
    进化引擎需评估图片/音频内容是否可提升; Promotion Pipeline 需处理 media_id 脱敏

Loop B: 知识沉淀闭环
  触发: 外部数据导入 / Skill 生成 / Promotion 审批
  路径: Admin API / ERP -> Knowledge Write API -> Neo4j + Qdrant(FK 联动)
        -> Resolver 可查询
  涉及层: Gateway + Knowledge Stores
  涉及契约: KnowledgeBundle schema(输出端), FK Registry
  完成条件: 数据写入两库 + FK 一致 + Resolver 可检索
  断裂影响: 新知识无法入库，Skill 使用过时数据
  v3.6 多模态影响 [High]: Knowledge Write API 新增媒体写入管线; FK 联动扩展到
    enterprise_media_objects; KnowledgeBundle schema 新增 media_contents; Qdrant payload 新增 media_refs

Loop C: 知识消费闭环
  触发: 用户对话中需要领域知识
  路径: Brain 意图判断 -> Skill Router 匹配 -> Resolver 按 Profile 查询
        -> KnowledgeBundle 组装 -> Skill 执行 -> Brain 整合回复
  涉及层: Brain + Skill + Tool + Knowledge Stores
  涉及契约: KnowledgePort, SkillRegistry, KnowledgeBundle schema, ToolProtocol
  完成条件: 用户获得基于企业知识的专业回答
  断裂影响: 退化为通用对话（无领域知识加持）
  v3.6 多模态影响 [High]: Skill 需处理多模态输入/输出 (multimodal_input/output);
    KnowledgeBundle 含 media_contents; LLMCallPort 扩展 content_parts;
    Brain Generation 阶段需选择多模态模型

Loop D: 计量反压闭环
  触发: 每次 LLM 调用
  路径（2 阶段）:
    Phase 1 Pre-check: Gateway 检查 org_settings.budget_monthly_tokens
      -> 剩余充足: 放行
      -> 已耗尽: 拒绝(402)
    Phase 2 Post-settle: LLM 响应返回后 -> 异步精确扣减实际消耗 token
      -> 即将耗尽(< 10%): 返回 X-Budget-Remaining 告警头
      -> 扣减后归零: 后续请求触发 Phase 1 拒绝
  涉及层: Gateway + 基础设施(Token Billing) + Brain(LLMCallPort)
  涉及契约: OrgContext(budget 字段), LLMCallPort, 计费事件 schema
  完成条件: 消耗被准确计量 + 超限被拦截
  断裂影响: 无法限制 Token 消耗，存在成本失控风险
  v3.6 多模态影响 [Medium]: Pre-check 扩展 budget_tool_amount 维度;
    Post-settle 扩展 tool_usage_records 扣减; X-Tool-Budget-Remaining 告警头

Loop E: 治理闭环
  触发: 管理员配置变更 / 权限调整
  路径: Admin Console -> Admin API -> OrgContext 更新
        -> Settings 继承链重算(is_locked BRIDGE 机制)
        -> RLS 策略生效 -> 下次请求即时生效
  涉及层: Gateway + 基础设施(组织模型/RBAC/RLS)
  涉及契约: OrgContext schema, LAW/RULE/BRIDGE 约束体系
  完成条件: 配置变更在下次请求时对整个 org_chain 生效
  断裂影响: 配置不生效或继承链断裂，子组织行为不受控
  v3.6 多模态影响 [Low]: org_settings 新增 media_config (allowed_media_types/file_size_limit/
    media_quota/nsfw_sensitivity/quarantine_expire_days); Settings 继承链对多模态配置生效;
    RLS 策略新增 personal_media_objects/enterprise_media_objects 两张表
```

> **Loop 间依赖:** Loop C 依赖 Loop B 的产出（知识已入库）；Loop A 的产出通过 Loop B 落地；Loop D 对 Loop C 施加反压（预算耗尽则 Loop C 中断）；Loop E 对所有 Loop 施加治理约束（权限/配置变更影响全链路）。

## 8. 调用关系

```
用户 -> Gateway -> Brain（对话 Agent 内核）
                    |
                    +-- 直接对话（不需要 Skill）:
                    |     Brain -> Context Assembler:
                    |       +-- Memory Core: 读取个人记忆/偏好 (必须)
                    |       +-- Knowledge Stores: 读取企业知识 (可选，降级运行)
                    |     Brain -> LLMCall Tool -> LLM Gateway
                    |     Brain -> 用户（回复）
                    |     Brain -> Memory Core: 写入观察/记忆（自动）
                    |
                    +-- 需要"做事"（调用 Skill）:
                          Brain -> Skill Registry -> 匹配 Skill
                          Brain -> Resolver -> 按 Skill Profile 预取 KnowledgeBundle
                          Brain -> Skill.execute(knowledge=KnowledgeBundle)
                          Skill -> Tool Registry -> 调用 Tool（Skill 内部）
                          Skill -> Brain -> 用户（返回结果）
                          Brain -> Memory Core: 写入观察/记忆（自动）

禁止的调用:
  X  Skill 之间互相调用（必须由 Brain 编排）
  X  Tool 调 Skill（Tool 是原子的，不知道 Skill 的存在）
  X  Knowledge Stores 读 Memory Core（隐私硬边界）
  X  Memory Core 有任何主动行为（被动读写）
```

## 9. 请求处理全流程

```
用户消息
  -> Gateway: Token 验证 -> 解析组织上下文
    -> Brain.对话引擎:
        -> Context Assembler:
            Step 0.5: Query Rewriting（低成本 LLM 改写用户查询为检索友好形式，见 01 Section 4.1）
            Step 1 (必须): Memory Core 检索
              session window（内存）
              personal memories: Hybrid Retrieval（FTS + pgvector 双路 + RRF 融合，见 01 Section 4.1 Step 1 / ADR-042）
              Multi-Signal Reranking（见 01 Section 4.1 Step 1.3）
              输出 personal_context
              失败 -> 系统不可用（硬依赖）; pgvector 不可用 -> 降级为 FTS-only

            Step 2 (可选): Knowledge Stores 检索（若 stores 可用）
              2a Qdrant enterprise semantic search
              2b Neo4j 图谱查询/推理
              2c FK 联动增强
              输出 knowledge_context

            Step 3: 合并组装 + 预算分配
              冲突解决: Knowledge 优先（企业规则 > 个人偏好）
              写 retrieval_receipt + injection_receipt

        -> 意图判断:
            +-- 纯对话 -> Brain 自行处理
            |     -> LLMCall Tool（注入组装后的上下文）
            |     -> 生成回复
            |     -> Memory 写入管线: 提取观察 -> 写入 Memory Core
            |
            +-- 需要"做事"
                  -> Skill Registry 查找匹配 Skill
                  +-- 找到 -> 调度 Skill 执行
                  |         Skill 使用 KnowledgeBundle + Tool
                  |         结果返回 Brain -> 回复用户
                  |
                  +-- 未找到 -> Brain 直接回复:
                            "我目前还没有这个能力，但我可以和你聊聊相关的话题"

                -> Memory 写入管线: 提取观察 -> 分析模式 -> 写入 Memory Core
                -> Token Billing: 记录消耗
                -> Audit: 记录溯源
```

## 10. 三条写入管线

```
管线 1: Memory 写入（自动）
  User Dialogue -> Observer -> Analyzer/Evolver -> Memory Core (append-mostly + versioned)
  产出: conversation_events, memory_items(versioned), injection/retrieval receipts
  自动学习只写 personal scope，必须可撤销/可降权（负反馈熔断）

管线 2: Knowledge 写入（受控）
  Admin/ERP/Skill/Batch -> Knowledge Write API -> (Neo4j/Qdrant)
  必过: ACL 校验、幂等键、审计回执、（文档类）脱敏与安全扫描
  ERP/PIM 同步走变更集（ChangeSet）以便审计与回滚

管线 3: Promotion Pipeline（跨域提案，需审批）
  Memory Core -> (candidate) -> sanitize/scan -> conflict/dedup -> approval -> Knowledge Stores
  这不是"Memory scope 升级"，而是跨 SSOT 的提案入库
  审批通过后写入 Neo4j/Qdrant enterprise 区域
  生成 promotion_receipt + knowledge_write_receipt
```

## 11. 降级矩阵与错误分类

### 11.1 错误分类

> 所有层的异常均归入以下三类，各层在自身文档中说明具体处理策略。

| 类型 | 定义 | 通用策略 | 举例 |
|------|------|---------|------|
| **Transient** | 暂时性故障，重试可恢复 | 重试 (exponential backoff + jitter)，最大 3 次 | 网络超时、LLM 429、Qdrant 暂时不可达 |
| **Permanent** | 不可恢复，需人工介入或上层降级 | 快速失败 + 记录 + 告警 | 认证失败、权限不足、数据格式非法 |
| **Degraded** | 部分能力丧失，核心链路仍可用 | 降级运行 + 记录 degraded_reason | Knowledge Stores 不可用、单 Skill 故障 |

### 11.2 降级矩阵

| 故障 | 影响 | 系统状态 |
|------|------|---------|
| Qdrant down | 无语义检索，仅图谱/仅关键词 | DEGRADED，记录 degraded_reason |
| Neo4j down | 无图推理，无结构化关系查询 | DEGRADED，记录 degraded_reason |
| Qdrant + Neo4j 都 down | 仍可对话 + 个人记忆；丧失领域知识 | DEGRADED |
| **Memory Core down** | **停服** | **UNAVAILABLE**，返回错误（降级免疫: Memory Core 降级 = 系统不可用，与 01 Section 3.2 一致） |
| 单个 Skill 故障 | 该 Skill 能力不可用 | DEGRADED，优雅降级回复 |
| LLM Gateway 主模型 down | Fallback 到备选模型 | DEGRADED |
| LLM Gateway 全部模型 down | 停服 | UNAVAILABLE |
| Object Storage down [v3.6] | 多模态功能不可用，文本对话不受影响 | DEGRADED，media_id URL 返回 503，前端展示 text_fallback |

### 11.3 幂等与重试约定

```
所有写操作:
+-- 必须携带 idempotency_key（由调用方生成）
+-- 接收方按 idempotency_key 去重
+-- 重试间隔: 100ms / 500ms / 2000ms (3 次上限)
+-- Jitter: +/- 20%

各层的具体超时、重试、降级策略在对应层文档中定义:
+-- Brain: Context Assembler 超时策略 -> 01-Brain Section 4.4
+-- Knowledge: FK 写入重试 -> 02-Knowledge Section 7.3
+-- Gateway: LLM Fallback + 限流 -> 05-Gateway Section 5.4 / 6
+-- 基础设施: 事件投递重试 -> 06-基础设施 Section 6
```

## 12. 解耦策略: 类型 A 接口级完全解耦

> **[v3.1 裁决]** 7 层架构采用 **Type A: Contract-based** 完全解耦。每层通过 Port 接口与其他层交互，可独立开发、测试、替换。

### 12.1 解耦定义

- **类型 A（接口级完全解耦）:** 层与层之间仅通过 Port（接口/协议）通信，无直接实例依赖。运行时数据流经 Port 传递，但 Port 本身可被 Stub/Mock 替换。
- **判定标准:** 每一层可独立编译/运行/测试，依赖的其他层全部以 Stub 注入。

### 12.2 渐进式接入序列与验证

系统按以下顺序逐层组合，每层接入时前序层零修改:

```
Step 1: Brain (+ Memory Core)
  -> 独立对话 Agent，有记忆状态，能识别意图
  -> 依赖: LLMCallPort(stub OK)
  -> 验证: 能对话、能记忆、能优雅降级

Step 2: + Tool 层
  -> Brain 通过 LLMCallPort 调用真实 LLM
  -> 验证: Step 1 全部测试仍 PASS + LLM 调用正常

Step 3: + Skill 层
  -> Brain 有了"手脚"，通过 SkillRegistry 调度 Skill
  -> Skill 通过 KnowledgePort(stub) 获取知识
  -> 验证: Step 1~2 全部测试仍 PASS + Skill 执行正常

Step 4: + Knowledge 层
  -> KnowledgePort 接入真实 Knowledge Stores
  -> Agent 有了专业知识储备
  -> 验证: Step 1~3 全部测试仍 PASS + 知识检索正常

Step 5: + Gateway 层
  -> OrgContext 接口接入真实组织上下文
  -> 验证: Step 1~4 全部测试仍 PASS + 多租户隔离正常

Step 6: + Infrastructure 层
  -> StoragePort 接入真实存储/计费/审计
  -> 验证: Step 1~5 全部测试仍 PASS + 基础设施正常

Step 7: + Deployment
  -> 部署模式选择（SaaS/私有/混合）
  -> 验证: 全链路端到端测试 PASS

--- 以下为外部消费者，不属于系统内部层 ---

Step 8: + Frontend UI（用户端）
  -> 消费 Gateway 的用户 API（/api/v1/* 不含 /admin）+ WebSocket /ws/conversations/{conversation_id} + SSE /events/*
  -> 不引入新 Port，不修改 Step 1~7 任何层
  -> 验证: Step 1~7 全部测试仍 PASS + 用户交互流程正常

Step 9: + Admin Console（管理端）
  -> 消费 Gateway 的管理 API（/api/v1/admin/*）
  -> 不引入新 Port，不修改 Step 1~7 任何层
  -> 验证: Step 1~7 全部测试仍 PASS + 管理操作流程正常
```

### 12.3 Day 1 Port 接口定义

> 以下 6 个 Port 接口必须在 Day 1 定义（即使实现为 Stub），确保从第一行代码起即为可解耦架构。

| Port | 职责 | Day 1 实现 | 真实实现 |
|------|------|-----------|---------|
| **MemoryCorePort** | 封装 Memory Core 读写（Brain 硬依赖） | SQLite 内存实现 | PostgreSQL（通过 StoragePort） |
| **LLMCallPort** | 封装所有 LLM 调用 | 返回固定文本的 Stub | LLM Gateway + Model Registry |
| **KnowledgePort** | 封装 Knowledge Stores 的读取 | 返回空 KnowledgeBundle 的 Stub | Diyu Resolver (Neo4j + Qdrant) |
| **SkillRegistry** | 技能发现与调度 | 空注册表，匹配永远返回"未找到" | YAML 注册 + 动态加载 |
| **OrgContext** | 封装组织上下文组装 | 返回默认单租户上下文的 Stub | Gateway 解析 JWT + 组织模型查询 |
| **StoragePort** | 封装通用持久化读写 | 内存 Map / SQLite | PostgreSQL + Redis |

> **Port 依赖层次:** MemoryCorePort 是领域语义接口（read_personal_memories / write_observation），其持久化实现内部委托 StoragePort。反向不成立：StoragePort 不感知 MemoryCorePort 的存在。Day 1 时 MemoryCorePort 可直接用 SQLite 内存实现，无需经过 StoragePort；真实实现时 MemoryCorePort 的 PG 适配器通过 StoragePort 访问数据库。

#### 12.3.1 v3.6 Extension Port

> **[v3.6 新增]** 以下 Port 不属于 Day 1 必需（Section 12.3 的 6 个 Day 1 Port 保持不变），而是 v3.6 多模态能力引入的扩展 Port。

| Port | 职责 | 独立性级别 | 引入版本 | 实现 |
|------|------|-----------|---------|------|
| **ObjectStoragePort** | 封装对象存储操作原语 (generate_upload_url / generate_download_url / delete_object / delete_objects / head_object) | Level 2 (Environment) | v3.6 | S3 / MinIO |

```
ObjectStoragePort 方法签名 (参数类型 + 返回类型):

  async generate_upload_url(
    bucket: str, key: str, mime_type: str,
    max_size: int, checksum_sha256: str,
    expires_in: int = 3600
  ) -> PresignedUploadURL
    -- PresignedUploadURL: {url: str, expires_at: datetime, conditions: Dict}

  async generate_download_url(
    bucket: str, key: str, expires_in: int = 900
  ) -> PresignedDownloadURL
    -- PresignedDownloadURL: {url: str, expires_at: datetime}

  async delete_object(bucket: str, key: str) -> None

  async delete_objects(bucket: str, keys: List[str]) -> BatchDeleteResult
    -- BatchDeleteResult: {deleted: List[str], errors: List[{key: str, error: str}]}

  async head_object(bucket: str, key: str) -> ObjectMetadata
    -- ObjectMetadata: {size_bytes: int, mime_type: str, checksum_sha256: str,
                        last_modified: datetime, storage_class: str}

设计约束:
  +-- Port 边界: 不含业务逻辑、安全扫描、权限校验，仅提供存储操作原语
  +-- 底层可替换: S3 / MinIO / OSS / GCS
  +-- 不属于 Day 1 Port: 多模态功能为 M1/M2 分期实现
  +-- Day 1 Port 表 (Section 12.3) 保持 6 个不变
  +-- 契约测试: 纳入 Layer 1 Port Schema 断言 (见 08 附录 G.4)
```

### 12.4 风险重评估（Type A 解耦后）

| 风险 | 解耦前严重度 | 解耦后严重度 | 说明 |
|------|-------------|-------------|------|
| OrgContext 膨胀 | Medium | **Low** | OrgContext 已接口化，Brain 只消费 Port 返回的标准结构体，Gateway 内部膨胀不影响 Brain |
| Memory Core 共置 | Medium | **Eliminated** | StoragePort 抽象后，Memory Core 存储引擎可独立替换（PG/SQLite/其他），不与其他层共置 |
| Context Assembler 瓶颈 | Low | **Low（性质变化）** | 不再是架构耦合风险，而是纯性能优化问题（并发读两个 SSOT 的延迟），可通过缓存/预取解决 |

### 12.5 Port 演进策略

> **[v3.3.1 新增]** Port 接口是层间解耦的核心支点。Port 签名的变更直接影响系统的向后兼容性。本节定义 Port 变更的分类标准和迁移方法。

```
Port 变更分类:

兼容变更（不破坏现有消费者）:
  + 新增可选参数（带默认值）
  + 新增返回结构中的可选字段（消费者可忽略）
  + 新增独立方法（不影响现有方法签名）
  + 放宽输入约束（如: 原本不允许 null，改为允许并有默认行为）

破坏性变更（需 expand-contract 迁移）:
  - 方法签名变更: 删除/重命名方法、修改参数类型、新增必填参数
  - 返回结构变更: 删除/重命名字段、修改字段类型或语义
  - 错误码变更: 删除已有错误码、修改错误码含义
  - 超时约定变更: 缩短 SLA 超时（消费者可能未准备好更快响应）
  - 时序语义变更: 改变调用的前置/后置条件、改变异步/同步行为
  - 行为语义变更: 相同输入产生不同输出（即使签名不变）

Expand-Contract 迁移方法:

  Phase 1 - Expand（扩展期）:
    +-- 新增新版方法/字段，保留旧版方法/字段
    +-- 新旧版本并行运行，消费者可逐步迁移
    +-- 标注旧版为 @deprecated(since="vX.Y", removal="vX.Y+2")

  Phase 2 - Migrate（迁移期，>= 1 minor version）:
    +-- 消费者逐步切换到新版方法/字段
    +-- 监控旧版调用量，确认趋零
    +-- CI 中运行新旧两套契约测试

  Phase 3 - Contract（收缩期，>= 旧版标记废弃后 2 个 minor version）:
    +-- 移除旧版方法/字段
    +-- 移除旧版契约测试
    +-- 变更记录中标注 BREAKING

Deprecation 规则:
  +-- 最小保留周期: 2 个 minor version（如 v3.3 标记废弃 -> v3.5 最早可移除）
  +-- @deprecated 注解必须包含: since 版本、计划移除版本、替代方案说明
  +-- 废弃期间旧方法必须仍通过所有测试
```

### 12.6 契约测试策略

> **[v3.3.1 新增]** 语义契约和 Port 签名仅在文档中定义是不够的，必须有可执行的测试保障其不被意外破坏。

```
三层契约测试:

Layer 1: Port Schema 断言测试
  目标: 验证 Port 接口的方法签名、参数类型、返回类型不被破坏
  实现:
    +-- 每个 Port 定义 interface/protocol + 类型注解
    +-- 测试用例: 构造 Stub 实现 -> 调用每个方法 -> 断言返回类型匹配
    +-- CI 触发: 每次 Port 文件变更时自动运行
  覆盖范围: MemoryCorePort, KnowledgePort, LLMCallPort, SkillRegistry, OrgContext, StoragePort,
             ObjectStoragePort [v3.6]

Layer 2: 语义契约 Snapshot 测试
  目标: 验证核心数据结构（KnowledgeBundle, MemoryItem, OrgContext）的字段不被意外修改
  实现:
    +-- 每个 schema v1 生成 snapshot 文件（JSON Schema 格式）
    +-- 测试用例: 构造合法实例 -> 序列化 -> 与 snapshot 比对
    +-- 新增可选字段: 更新 snapshot（兼容变更，CI 提示 review）
    +-- 删除/重命名字段: snapshot 比对失败 -> CI 阻断（破坏性变更）
  覆盖范围:
    +-- KnowledgeBundle v1（见 02 Section 5.4.1）+ media_contents 扩展 [v3.6]
    +-- MemoryItem v1（见 01 Section 2.3.1）
    +-- OrgContext v1（见 05 Section 4.2）
    +-- ContentBlock Schema v1.1 [v3.6]
    +-- MultimodalMessage (WS payload) [v3.6]

Layer 3: 事件契约测试（Consumer-Driven Contract Testing）
  目标: 验证事件生产者发出的 event_type + payload 符合消费者预期
  实现:
    +-- 消费者定义期望的事件 schema（event_type, 必需字段, 字段类型）
    +-- 生产者测试: 构造事件 -> 断言符合所有消费者契约
    +-- 新增事件类型: 不破坏（消费者忽略未订阅的类型）
    +-- 修改已有事件的 payload: 需通过所有消费者契约测试
  覆盖范围:
    +-- Level 1 关键事件: 审计事件、计费事件、回执事件（见 06 Section 6）
    +-- Level 1 关键事件: media_event (7 个子类型) [v3.6]
    +-- Level 2 普通事件: 通知事件、缓存失效事件

Layer 4: 持久化数据版本兼容测试 [v3.5 新增, v3.6 扩展]
  目标: 验证 N+1 版本代码能正确处理所有历史版本的持久化数据
  实现:
    +-- 每个版本保存样本数据 (Fixture)
    +-- CI 中验证 N+1 版本代码能正确解析所有历史 Fixture
  覆盖范围:
    +-- memory_items: content_schema_version 1 样本
    +-- event_outbox: payload_version 1 样本
    +-- memory_receipts: details_schema_version 2/3/3.1 样本
    +-- conversation_events: content_schema_version=0 + =1 样本 [v3.6]
    +-- personal_media_objects / enterprise_media_objects: v1 样本 [v3.6]
    +-- tool_usage_records: v1 样本 [v3.6]
  详见: 06 Section 6.4, 08 附录 G.4

CI 集成:
  +-- PR 级: Layer 1 + Layer 2 必须通过，否则阻断合并
  +-- 日构建: Layer 3 + Layer 4 完整运行（含跨服务事件契约 + 持久化兼容）
  +-- 破坏性变更检测: snapshot diff + 自动标注 PR 为 BREAKING CHANGE
```

---

## 13. 企业级鲁棒性

```
- 记忆资产版本化 + provenance + 可回滚（Memory Core 内）
- 注入 fail-closed + 负反馈熔断（防正反馈毒化）
- Knowledge 写入幂等 + 审计回执 + 变更集（Neo4j/Qdrant 内）
- 对抗性内容检测 + 脱敏控制面（跨域写入与提案必须过）
- 全链路 trace_id: 对话事件 -> 检索 -> 注入 -> (若发生) promotion -> knowledge 写入
```

---

## 14. 治理架构概览

> **[v3.5 新增]** 本章描述治理架构的运营模型（How），与 Section 7.5 跨层闭环架构（What）互补，不重复。

```
双 Loop 治理架构:

=== Runtime Governance Loop（运行时治理） ===
  对应 Section 7.5 Loop A/C，关注对话质量实时保障

  Step 1: Context Assembly -> 注入决策 + 五元组记录
  Step 2: injection_receipt / retrieval_receipt 写入
  Step 3: SLI 聚合（7 项统一指标，见 01 Section 2.3.2）
  Step 4: 告警评估（MWMBR 模式 + 低流量最小样本量阈值）
  Step 5: 治理动作（清理 Job / LLM resolution / 告警升级）
  Step 6: 策略调整（通过 Experiment Engine 灰度发布）

=== Data Lifecycle Pipeline（数据生命周期管线） ===
  对应 Section 7.5 Loop E，关注合规和数据治理

  Step 1: 删除请求 -> tombstone 创建（8 态状态机）
  Step 2: Outbox Level 1 投递
  Step 3: Physical Deletion Worker 执行（按 legal_profile SLA）
  Step 4: 审计留存（audit_event + tombstone 永久保留）
  Step 5: 合规验证（deletion_timeout_rate SLI = 0% 零容忍）

=== Shared Governance Layer（共享治理层） ===
  两条 Loop 共享的基础设施:

  +-- Policy Pack: org_settings 按租户配置治理阈值
  +-- Unified Event Model: decision_event / deletion_event / degrade_event（见 06 Section 6.3）
  +-- Observability: Prometheus + Grafana + Langfuse（见 08 附录 D）
  +-- Experiment Engine: 策略变更灰度发布（见 06 Section 5, ADR-023）
```

### 14.1 Phase 演进路线图

> **[v3.5 新增]** 仅列事项名称 + 交叉引用，不重复技术细节（对齐 V2.1 D3 规则）。

```
Phase 0（核心闭环）:
  +-- PK 命名统一（详见 01 Section 2.3.1 + 06 Section 8）
  +-- 注入正确性闭环（详见 01 Section 4.1 + 2.3.2）
  +-- 动态预算分配器 v1（详见 01 Section 4.2.1, ADR-035）
  +-- 删除管线 8 态状态机（详见 01 Section 3.1.1, ADR-039）
  +-- SLO 可观测性 7 项 SLI（详见 01 Section 2.3.2, ADR-038）
  +-- [CE] pgvector 默认启用 + Hybrid Retrieval + RRF（详见 01 Section 3.2.1 / 4.1 Step 1, ADR-042）
  +-- [CE] Query Rewriting（详见 01 Section 4.1 Step 0.5）
  +-- [CE] Multi-Signal Reranking 五因子排序（详见 01 Section 4.1 Step 1.3）
  +-- [CE] 结构化标签增强 + U-shaped 排布 + 动态注入量（详见 01 Section 4.1 Step 3）
  +-- [CE] Memory-Aware Instruction system_prompt 模板（详见 01 Section 2.1）
  +-- [CE] 后处理闭环: 利用检测 + 隐式反馈 + injection_receipt v3.1（详见 01 Section 4.1.1）
  +-- [CE] Evolution 纠正快速通道 + 结构化 Analysis Prompt（详见 01 Section 2.3.0.1 增强A/B）

Phase 1（治理增强）:
  +-- Executor 分区: 热路径/冷路径隔离（详见 01 Section 5.1）
  +-- Memory Governor 组件: 治理逻辑独立封装（详见 01 Section 2.3.2.3）
  +-- Read Replica: 分析查询走 Standby（详见 07 Section 6.1）
  +-- TruncationPolicy: FixedPriorityPolicy 实现（详见 01 Section 4.2.1）
  +-- Sanitization: pattern-based 清洗（详见 01 Section 4.1 Step 1.5）
  +-- 评测集: 200 条标注样本（详见 01 Section 2.3.2.1）
  +-- [CE] Contextual Chunking: embedding 前缀增强（详见 01 Section 2.3.0.1 增强C）
  +-- [CE] Memory Consolidation: 相似记忆合并（详见 01 Section 2.3.0.1 增强D）

Phase 2（能力扩展）:
  +-- AssemblyProfile: 多次异构 LLM 调用支持（详见 01 Section 4.2.1 注释）
  +-- BookmarkPort: Knowledge -> Memory 引用通道（详见 01 Section 6）
  +-- Task Orchestration: 异步长任务编排（详见 01 Section 2.6）
  +-- 成本控制三策略:
      模型降级: LLMCallPort 增加 model_selection_hint（详见 05 Section 5）
      语义缓存: 高频查询结果缓存（详见 01 Section 4.4）
      Prompt 压缩: 减少 token 消耗（详见 01 Section 4.2）
  +-- Crypto Shredding: per-user 加密密钥（详见 07 Section 5.2）
  +-- Sanitization LLM-based: 低成本模型判定（详见 01 Section 4.1 Step 1.5）
  +-- [CE] Confidence Calibration 批量校准（详见 01 Section 2.3.2.5）
  +-- [CE] Phase-Aware System Prompt 动态重点切换（详见 01 Section 2.1）
  +-- [CE] Intent-Based Model Routing 意图级模型选择（详见 01 Section 4.2.1 注释）

Phase 3（平台化）:
  +-- Capability Registry: 统一 Skill/Tool/Model/EntityType 注册中心
  +-- 可解释性面板: injection_receipt.explanation_trace
  +-- Event Mesh 演进: PG Outbox+Celery -> NATS/Kafka -> Schema Registry
```

### 14.2 v3.6 多模态实施分期路线图

> **[v3.6 新增]** 多模态分期 (M0-M3) 与上述 Phase 路线图正交。Phase 关注系统整体演进，M 系列专注多模态能力的渐进式交付。两者可并行推进，M0 建议与 Phase 0 同步完成。

```
M0: 基座期 (无用户可见变化)
  +-- ContentBlock Schema v1.1 定义 + JSON Schema 验证 (ADR-043)
  +-- ObjectStoragePort 接口 + S3/MinIO 实现 (00 Section 12.3.1)
  +-- personal_media_objects / enterprise_media_objects DDL + RLS (06 Section 9)
  +-- tool_usage_records DDL (06 Section 9)
  +-- conversation_events.content_schema_version 列 (06 Section 9)
  +-- usage_budgets.budget_tool_amount 列 (06 Section 9)
  +-- event_outbox 注册 media_event 类型 + idempotency_key 规范 (06 Section 6.3)
  +-- LLMCallPort content_parts 可选参数 Expand (05 Section 9, ADR-046)
  +-- 安全管线 Stage 1 同步预检 (05 Section 8.2)
  +-- 配额预扣 + 超时回收定时任务 (05 Section 8.2)
  +-- ADR-049 tier 命名修正 (06 Section 1.6.1)
  +-- 契约测试: Layer 1-4 全量新增条目 (08 附录 G.4)

M1: 个人多模态 (用户可发送/接收图片和语音)
  +-- 个人媒体上传 API 三步协议 + S3 原生 checksum (05 Section 8)
  +-- WS ai_response_chunk / user_message payload 扩展 (05 Section 7.1)
  +-- ImageAnalyze Tool + AudioTranscribe Tool (04 Section 3) [ImageGenerate 远期]
  +-- Brain Generation 阶段多模态模型选择逻辑 (01 Section 4.1)
  +-- Context Assembler Step 1.5 覆盖 OCR/ASR 输出 (01 Section 4.1)
  +-- Loop D Pre-check 扩展 budget_tool_amount (05 Section 8.4)
  +-- security_status 三层拦截实现 (05 Section 8.3)
  +-- 安全管线 Stage 2 异步深度扫描 (横切: 基础设施层 Worker)
  +-- 个人媒体删除管线 tombstone + 全覆盖 (06 Section 9.1)

M2: 企业多模态 (知识库支持媒体资产)
  +-- 企业媒体上传 API 三步协议 /admin/knowledge/ 路径 (05 Section 8.1)
  +-- KnowledgeBundle media_contents 扩展 (02 Section 5.4.1)
  +-- enterprise_media_objects 与 Neo4j FK 联动 (02 Section 3.6)
  +-- Qdrant 向量 payload media_refs 扩展 (02 Section 3.6)
  +-- 应用层 visibility 继承过滤 (复用 Resolver 逻辑)
  +-- Skill multimodal_input/output 能力声明 (03 Section 2)
  +-- DocumentExtract Tool (04 Section 3)
  +-- 企业媒体删除管线 ChangeSet + 图谱级联 (02 Section 7.1)
  +-- Promotion Pipeline 多模态脱敏 (02 Section 7.2)

M3: 成熟期
  +-- 版权风险检测 (Stage 2 扩展)
  +-- 视频流式处理
  +-- 跨模态语义检索
  +-- LLMCallPort Contract 阶段评估 (ADR-046)
```

---

## 文档索引

| 文档 | 层 | 说明 |
|------|---|------|
| [00-系统定位与架构总览](./00-系统定位与架构总览.md) | 总览 | 本文档 |
| [01-对话Agent层-Brain](./01-对话Agent层-Brain.md) | 核心对 | Brain 5大固有能力 + SSOT-A(Memory Core) + Context Assembler |
| [02-Knowledge层](./02-Knowledge层.md) | 知识层 | SSOT-B + FK联动 + Resolver + 实体注册 + Promotion Pipeline |
| [03-Skill层](./03-Skill层.md) | 能力层 | Skill协议 + 生命周期 + 具体Skill设计 |
| [04-Tool层](./04-Tool层.md) | 能力层 | Tool协议 + Tool清单 + MCP适配器 |
| [05-Gateway层](./05-Gateway层.md) | 网关层 | 接入协议 + 认证鉴权 + LLM Gateway |
| [06-基础设施层](./06-基础设施层.md) | 基础层 | 服务 + 存储 + PG数据模型 + 组织模型 |
| [07-部署与安全](./07-部署与安全.md) | 外壳层 | 部署模式 + 数据安全 + 合规 |
| [08-附录](./08-附录.md) | 参考 | 术语 + ADR + 技术栈 + 待决 + 配置 |

---

> **文档版本:** v3.6
> **核心变更:** v3.2.1 基础上新增: 架构元模型三级独立性梯度(Section 7.4); 跨层业务闭环5条Loop(Section 7.5); 语义契约v1: KnowledgeBundle/MemoryItem/OrgContext; Port演进策略+Expand-Contract迁移(Section 12.5); 契约测试三层策略(Section 12.6); LAW约束参数化评估(06 Section 1.6.1); 契约索引表(08 附录G); ADR-031~034; **v3.5: 治理架构双Loop运营模型(Section 14)+Phase路线图(Section 14.1)+append-mostly修正+降级免疫规则+CP/DP分离视角**; **v3.5.1: CE优化落盘(pgvector/Hybrid Retrieval/Reranking/后处理闭环/Evolution增强/confidence_effective)**; **v3.6: 多模态能力架构(ContentBlock/双域媒体存储/三步上传/安全状态机/ObjectStoragePort Extension Port/LLMCallPort Expand/Tool独立计费/Loop影响矩阵v3.6扩展/降级矩阵v3.6扩展/契约测试基线同步/M0-M3实施分期路线图(Section 14.2)); ADR-043~052; 9文档全量升级v3.6**
