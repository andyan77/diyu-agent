# 多模态能力架构设计 -- 终态合并版

> **版本:** v3.4 (终态合并) | **日期:** 2026-02-10
> **基线:** 架构文档 v3.5.x 全量 (00-08)
> **审查轮次:** 7 轮 (v1 -> v2 -> v3 -> v3.1 -> v3.2 -> v3.3 -> v3.4)
> **状态:** 有条件通过 (Approve with conditions)
> **设计原则:** 层级完全解耦、向后兼容 (ADR-033 Expand-Contract)、层内自洽闭环、层间一致性对齐
> **验证标准:** 每层修改包含回退条件；5 条 Loop 影响矩阵已验证；横切关注点不引入新层级

---

## 审查历史

| 轮次 | 版本 | 修正条数 | 关键修正 |
|------|------|---------|---------|
| R1 | v1 -> v2 | 12 P0 | 双 SSOT 媒体分离; ObjectRef 禁止 presigned_url; 删除覆盖矩阵; 5 Loop 影响纠正 (全量受影响); 两阶段安全管线; tool_usage_records 独立计费; ADR 扩展为 6 个 |
| R2 | v2 -> v3 | 10 P0 | WS 保留 ai_response_chunk/tool_output/task_complete; API 双路分离; enterprise 删除走 ChangeSet; RLS SQL 化; LLMCallPort Expand 迁移计划; Loop D 覆盖 Tool 成本; OCR/ASR 复用 Step 1.5; media_event 定义; 横切关注点替代 Layer 5/6 |
| R3 | v3 -> v3.1 | 6 P0 | 外部 media_id 统一 (禁止暴露 ObjectRef); 版本号映射表; enterprise 解耦 tombstone; RLS 增强 visibility; 安全检查时序表; 契约测试四层条目 |
| R4 | v3.1 -> v3.2 | 5 P0 + 3 P1 | 版本号三层分离原则; RLS 硬隔离+应用层继承; S3 原生 checksum; 三层安全拦截; 配额超时回收; ADR-049 实际修正; org_scope 补齐; media_event 幂等键 |
| R5 | v3.2 -> v3.3 | 5 P0 + 2 P1 | idempotency_key 去 timestamp; enterprise 删除顺序 Qdrant-first; RLS 双向(祖先+子树); enterprise_media 补 tenant_id; 跨库最终一致性; WS 分支规则精确化; max_org_depth 基线确认 |
| R6 | v3.3 -> v3.4 | 1 P0 + 2 P1 | 删除管线不可逆操作后置; RLS tenant_id 双保险列为 M2 验证项; R5 计数笔误修正 |

---

## 一、统一内容模型: ContentBlock Schema v1.1

```
ContentBlock Schema v1.1:
  type: "text" | "image" | "audio" | "video" | "document"
  text: Optional[str]              -- type=text 时必填
  media_id: Optional[UUID]         -- type!=text 时必填
  metadata: Optional[Dict]         -- MIME type, duration, dimensions
  text_fallback: str               -- 必填，所有类型均提供纯文本回退

ID 模型规则 (LAW):
  外部接口 (API / WS / ContentBlock / Skill / Brain):
    统一使用 media_id: UUID
    禁止暴露 bucket / key / presigned_url

  存储层内部 (ObjectStoragePort 实现 / 安全管线 Worker / LLMCallPort 实现):
    通过 media_id -> 查表获取 ObjectRef (bucket/key/checksum/size/mime)
    ObjectRef 仅在存储层代码内流转

  ObjectRef (存储层内部结构，禁止跨层传递):
    bucket: str
    key: str                      -- 格式: {org_id}/{scope}/{uuid}.{ext}
    checksum_sha256: str
    size_bytes: int
    mime_type: str

  解析责任边界:
    media_id -> ObjectRef 的解析仅发生在:
      1. ObjectStoragePort 实现层 (生成 URL / 执行删除)
      2. 安全管线 Worker (读取文件做扫描)
      3. LLMCallPort 实现层 (构建 LLM API payload)
    其余所有层级仅传递 media_id

兼容性:
  现有 content JSONB 字段 (conversation_events.content, memory_items.content)
  当前值: {"text": "..."} 或纯字符串
  扩展后: {"blocks": [ContentBlock], "text_fallback": "..."}
  向后兼容: 无 "blocks" 字段时视为纯文本
  注: content JSONB 内禁止放版本号 (版本由行级列决定，见版本号分层原则)
  遵循 ADR-033: 新增可选字段 = 兼容变更
```

---

## 二、版本号三层分离原则

```
Layer A - DB 行级版本 (消费方: 后端服务):
  字段: content_schema_version (INTEGER, 列级)
  位置: PG 表列 (conversation_events, memory_items 等)
  规则: content JSONB 内部禁止放版本号
  消费: 读取时先查列值，再按值分支解析 content JSONB

Layer B - WS 消息级版本 (消费方: 前端):
  字段: content_version (INTEGER, payload 顶层)
  位置: WS 下行/上行消息 payload 的顶层字段
  规则: 缺失 = v0 (纯文本兼容)
  消费: 前端按 content_version 决定渲染策略

Layer C - 事件级版本 (消费方: 异步 Worker):
  字段: payload_version (INTEGER, event_outbox 列级)
  位置: event_outbox 表列 (已有)
  规则: 每种 event_type 独立编号，从 1 起
  消费: Worker 按 event_type + payload_version 分支

交叉禁止 (LAW):
  - content JSONB 内禁止出现 schema_version / content_version (防重叠)
  - WS payload 内禁止出现 content_schema_version (防混淆)
  - 三层版本号互不引用、互不依赖

版本号完整映射:

| 版本号字段 | 作用域 | 起始值 | 语义 | 消费端分支 |
|-----------|-------|-------|------|----------|
| conversation_events.content_schema_version | PG 行级 | 0 | 0=纯文本(存量), 1=ContentBlock v1.1 | 读取时按值分支解析 content JSONB |
| WS payload.content_version | WS 消息级 | (缺失) | 缺失=纯文本(旧客户端), 1=含 blocks 数组 | 前端以 content_version 为主判断，blocks 存在性为防御性检查 (见 Section 3.15) |
| event_outbox.payload_version | 事件级 | 1 | 事件 payload 结构版本，每种 event_type 独立编号 | Worker 按 event_type + payload_version 分支 |
| memory_items.content_schema_version | PG 行级(已有) | 1 | memory_items.content JSONB 结构版本 | 已有逻辑不变 |
| memory_receipts.details_schema_version | PG 行级(已有) | 1 | receipt details JSONB 结构版本 | 已有逻辑不变 |
```

---

## 三、各层修改

### Layer 1: 基础设施层 (06-基础设施层.md)

#### 3.1 新增 DDL: personal_media_objects

```sql
-- 个人媒体对象 (SSOT-A 域, 与 memory_items 同级)
CREATE TABLE personal_media_objects (
  media_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL,
  tenant_id UUID NOT NULL,
  bucket TEXT NOT NULL,
  key TEXT NOT NULL UNIQUE,
  checksum_sha256 TEXT NOT NULL,
  size_bytes BIGINT NOT NULL,
  mime_type TEXT NOT NULL,
  media_type TEXT NOT NULL CHECK (media_type IN ('image','audio','video','document')),
  security_status TEXT NOT NULL DEFAULT 'pending'
    CHECK (security_status IN ('pending','scanning','safe','rejected','quarantined','expired')),
  scan_result JSONB,                -- 安全扫描详情
  tombstone_id UUID REFERENCES tombstones(tombstone_id),  -- SSOT-A 删除走 tombstone
  quota_reserved_bytes BIGINT DEFAULT 0,                  -- 配额预扣 (v3.2)
  created_at TIMESTAMPTZ DEFAULT now()
);

-- RLS: 与 memory_items 对齐，按 user_id + tenant_id 隔离
ALTER TABLE personal_media_objects ENABLE ROW LEVEL SECURITY;
CREATE POLICY user_isolation ON personal_media_objects
  USING (user_id = current_setting('app.current_user_id')::uuid
         AND tenant_id = current_setting('app.current_tenant_id')::uuid);
```

#### 3.2 新增 DDL: enterprise_media_objects

```sql
-- 企业媒体对象 (SSOT-B 域, 与 Knowledge Stores 对齐)
CREATE TABLE enterprise_media_objects (
  media_id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID NOT NULL,             -- v3.3: 与 Neo4j 图谱节点 tenant_id 对齐 (02-Knowledge层.md:79)
  org_id UUID NOT NULL REFERENCES organizations(org_id),
  brand_id UUID,
  uploaded_by UUID NOT NULL REFERENCES users(user_id),
  bucket TEXT NOT NULL,
  key TEXT NOT NULL UNIQUE,
  checksum_sha256 TEXT NOT NULL,
  size_bytes BIGINT NOT NULL,
  mime_type TEXT NOT NULL,
  media_type TEXT NOT NULL CHECK (media_type IN ('image','audio','video','document')),
  visibility TEXT NOT NULL DEFAULT 'store'
    CHECK (visibility IN ('global','brand','region','store')),
  org_scope TEXT,                    -- 与 Neo4j 图谱节点 org_scope 对齐 (02-Knowledge层.md:81)
  security_status TEXT NOT NULL DEFAULT 'pending'
    CHECK (security_status IN ('pending','scanning','safe','rejected','quarantined','expired')),
  scan_result JSONB,
  graph_node_id TEXT,                -- 关联 Neo4j 节点 (FK 联动, 可选)
  deletion_changeset_id UUID,        -- 关联 Knowledge ChangeSet 记录 (SSOT-B 删除走 ChangeSet)
  deleted_at TIMESTAMPTZ,            -- 软删除时间戳 (NULL = 未删除)
  quota_reserved_bytes BIGINT DEFAULT 0,  -- 配额预扣 (v3.2)
  created_at TIMESTAMPTZ DEFAULT now()
);

-- RLS: 硬隔离 (租户维度 + 组织链双向)，visibility 精确判定在应用层
ALTER TABLE enterprise_media_objects ENABLE ROW LEVEL SECURITY;
CREATE POLICY tenant_org_isolation ON enterprise_media_objects
  USING (
    org_id IN (
      SELECT org_id FROM organizations
      WHERE path <@ current_setting('app.current_org_path')::ltree   -- 子树 (下级资产)
         OR current_setting('app.current_org_path')::ltree <@ path   -- 祖先链 (上级继承资产)
    )
  );
-- v3.3 修正: 仅子树方向会过滤掉 brand/global 级别的父节点资产，
-- 导致应用层无法做继承判定。增加祖先链方向后:
--   store 用户可看到 brand 级媒体 (path = root.brand_a, 是 store path 的祖先)
--   应用层再按 visibility + org_chain 做精确过滤 (Section 3.3)
-- 注: content_tasks 等已有表不受影响 (无继承语义)
-- M2 验证项: 确认所有企业域调用路径均设置 app.current_tenant_id session variable 后,
-- 可追加 AND tenant_id = current_setting('app.current_tenant_id')::uuid 作为防御纵深。
-- 当前 org_path ltree 已隐含租户边界 (不同租户组织树根不同), tenant_id 为第二道防线。

-- 删除管线域模型分离 (LAW):
--   personal_media_objects -> tombstone 状态机 (SSOT-A, PIPL/GDPR)
--   enterprise_media_objects -> Knowledge ChangeSet (SSOT-B, ACL+审计)
--   两条管线独立，不互引
```

#### 3.3 可见性继承判定 (应用层)

```
查询流程:
  1. PG RLS 过滤: 返回当前 org 祖先链 + 子树下所有 enterprise_media_objects (双向放行)
  2. 应用层过滤: 对结果集按 visibility + org_chain 做继承判定:
     - global: 所有组织可见 -> 保留
     - brand: 当前用户的 brand_id 匹配 -> 保留
     - region: 当前用户 org_chain 中包含该媒体的 owner org -> 保留
     - store: 当前用户 org_id = 媒体 org_id -> 保留
  3. ACL 细粒度: 对通过 visibility 的结果再做 acl JSONB 判定

与 Knowledge Stores Resolver 的关系:
  Resolver 已实现 visibility + org_chain 过滤逻辑 (02-Knowledge层.md:82-83)
  enterprise_media 查询可复用同一过滤函数:
    filter_by_visibility(items, current_org_chain, current_brand_id)

为什么 visibility 精确判定不放 RLS:
  - RLS 双向放行 (祖先+子树) 保证应用层能看到所有候选行
  - visibility + ACL 的精确判定涉及 org_chain 上溯 + tier 匹配，SQL 表达复杂且性能差
  - visibility 规则可能随业务演进 (如新增 "department" 级别)，应用层修改成本低
  - 职责分离: RLS 保证租户/组织链安全底线，应用层保证业务正确性
```

#### 3.4 新增 DDL: tool_usage_records

```sql
-- Tool 计费记录 (与 llm_usage_records 分离)
CREATE TABLE tool_usage_records (
  id BIGSERIAL PRIMARY KEY,
  org_id UUID NOT NULL REFERENCES organizations(org_id),
  user_id UUID NOT NULL,
  brand_id UUID,
  tool_name TEXT NOT NULL,       -- 对齐 04-Tool层 ToolProtocol.name
  tool_version TEXT NOT NULL,
  skill_id TEXT,                 -- 调用方 Skill
  input_summary TEXT,            -- 脱敏后摘要
  duration_ms INTEGER,
  cost_amount NUMERIC(12,6) NOT NULL,
  billing_unit TEXT NOT NULL,    -- 'per_call' | 'per_image' | 'per_minute'
  status TEXT NOT NULL CHECK (status IN ('success','error','rate_limited')),
  created_at TIMESTAMPTZ DEFAULT now()
);
```

#### 3.5 usage_budgets 扩展 (Expand 兼容变更)

```sql
ALTER TABLE usage_budgets ADD COLUMN budget_tool_amount NUMERIC(12,6);
-- 现有 budget_tokens + budget_amount 保留, budget_tool_amount 为独立维度
-- Pre-check 时: 分别校验 token 预算 和 tool 金额预算
-- Post-settle 时: tool_usage_records 异步扣减 budget_tool_amount
```

#### 3.6 conversation_events 扩展 (Expand 兼容变更)

```sql
ALTER TABLE conversation_events ADD COLUMN content_schema_version INTEGER DEFAULT 0;
-- 0 = 存量纯文本格式 (向后兼容)
-- 1 = ContentBlock Schema v1.1 (含 blocks 数组)
-- 读取时: schema_version=0 -> 按原逻辑解析; schema_version=1 -> 按 ContentBlock 解析
-- 遵循 ADR-033 Expand-Contract:
--   Expand: 新增列，默认值 0，旧代码忽略此列
--   Migrate: 新写入使用 version=1，旧数据保持 version=0 不迁移
--   Contract: 待所有消费端升级后 (最小 2 minor versions)，移除 v0 兼容分支

-- content JSONB 格式:
--   v0 (存量): {"text": "..."} 或纯字符串
--   v1 (新写入): {"blocks": [ContentBlock], "text_fallback": "..."}
--   注: 无版本号字段，版本由行级列 content_schema_version 决定
```

#### 3.7 Unified Event Model 扩展: media_event

```
新增事件类型 media_event:
  子类型:
    media.upload_initiated     -- 上传流程启动 (记录 media_id, uploader, intent)
    media.upload_completed     -- 上传完成 (S3 confirm + 同步预检通过)
    media.upload_expired       -- 上传超时未 complete (配额回收)
    media.scan_completed       -- 异步深度扫描完成 (含结果)
    media.rejected             -- 安全扫描拒绝
    media.deletion_requested   -- 删除请求 (intent 记录)
    media.deletion_completed   -- 删除完成 (所有存储位置确认清除)

  遵循现有 event_outbox 规范:
    payload_version: INTEGER DEFAULT 1
    Level 1 投递 (同事务写入 event_outbox)
    共享字段: event_id, trace_id, tenant_id, timestamp, policy_version

  media_event 特有字段:
    media_id: UUID
    media_domain: "personal" | "enterprise"   -- 标识 SSOT 归属
    media_type: "image" | "audio" | "video" | "document"
    action_detail: JSONB                       -- 子类型特有数据

  idempotency_key 格式 (与 event_outbox UNIQUE 约束对齐):
    个人域模板: media:{media_id}:{action}
    企业域模板: media:{media_id}:{action}:{changeset_id}
    超时回收模板: media:{media_id}:expired
    示例: media:550e8400-...:upload_completed
    示例: media:550e8400-...:deletion_completed:cs-789...
    规则: 禁止包含 timestamp (同一业务动作重试时 key 必须相同，才能被 UNIQUE 约束去重)
    设计依据: media_id 全局唯一 + action 枚举固定 = 天然幂等;
              企业删除通过 changeset_id 区分不同 ChangeSet 操作
```

#### 3.8 Tier 命名缺陷修正 (ADR-049, M0 落地)

```
06-基础设施层.md line 263 修正:
  现有: tier_types TEXT[] DEFAULT ARRAY['headquarters','province','city','store']
  修正: tier_types TEXT[] DEFAULT ARRAY['platform','brand_hq','brand_dept','regional_agent','franchise_store']

联动检查:
  max_org_depth: 确认基线已为 5 (06-基础设施层.md:262 DEFAULT 5)，无需修改
  tier_types: 4 元素 -> 5 元素 (唯一实际变更)
  确认系统中无代码硬编码旧 tier 名称

执行方式: 作为 M0 基座期的文档修正任务，与多模态 DDL 一同提交
```

---

### Layer 2: Brain + Memory Core (01-对话Agent层-Brain.md)

#### 3.9 Context Assembler 扩展

```
Step 1.5 Sanitization 覆盖范围扩展:
  现有: personal_context 中每条 memory_item.content 执行双重清洗
  新增: 多模态解析结果 (OCR 文本、ASR 转录文本、文档提取文本)
         在注入 Context 前必须经过同一 Sanitization Step

  具体流程:
    media content -> OCR/ASR/Extract Tool -> 纯文本结果
    -> Step 1.5 Sanitization (Pattern-based + LLM-based)
    -> pass: 注入 Context (附 text_fallback)
    -> blocked: 记录 injection_receipt.sanitization_result, 使用 text_fallback 替代

  设计原则: 不新建清洗管线，复用 Step 1.5 现有能力
  新增的是输入来源，不是清洗逻辑
```

#### 3.10 ContentBlock 在 Brain 中的使用

```
Brain 对 ContentBlock 的处理:
  接收: WS user_message 中可能包含 ContentBlock 数组
  存储: 写入 conversation_events.content (content_schema_version=1)
  读取: Context Assembler Step 1 检索时，按 content_schema_version 分支解析
  传递: 调用 LLMCallPort 时通过 content_parts 参数传递

  向后兼容:
    Brain 5 固有能力不受影响 (Intent/Entity/Routing/Generation/Evolution)
    ContentBlock 仅影响数据载体格式，不改变推理逻辑
    降级: 不支持多模态的模型 -> 使用 text_fallback
```

---

### Layer 3: Knowledge Stores (02-Knowledge层.md)

#### 3.11 enterprise_media_objects 与 Knowledge Stores 的 FK 联动

```
企业媒体与图谱的关联:
  enterprise_media_objects.graph_node_id -> Neo4j node_id
  遵循 02-Knowledge层.md:436-438 的 FK 规则:
    写入图谱节点的媒体属性时，必须同步创建 enterprise_media_objects 记录
    删除图谱节点时，必须级联删除关联的 enterprise_media_objects

  Qdrant 扩展:
    enterprise collection 的向量 payload 新增 media_refs 字段:
    {
      "graph_node_id": "...",
      "source_type": "enterprise",
      "org_id": "...",
      "media_refs": [{"media_id": "...", "media_type": "image", "text_fallback": "..."}]
    }
    向后兼容: media_refs 为可选字段，旧条目无此字段不影响检索
```

#### 3.12 Knowledge Write API 扩展

```
Knowledge Write API 已有管线 (02-Knowledge层.md:426-439) 新增:
  +-- 媒体文件安全扫描 (与文档类脱敏并列)
  +-- enterprise_media_objects 记录创建 (PG 事务内，含 event_outbox)
  +-- Neo4j/Qdrant 联动: 遵循 FK 协议最终一致性 (sync_status + Reconciliation Job)
  +-- FK: graph_node_id 必须指向已存在的 Neo4j 节点
  注: PG/Neo4j/Qdrant 为异构存储，无法分布式事务。
      PG 事务保证 media record + outbox 原子性;
      Neo4j/Qdrant 写入通过 FK 协议 (02-Knowledge层.md:490-506) 保证最终一致性

  KnowledgeBundle Schema v1 扩展:
  {
    entities: [...],
    relationships: [...],
    semantic_contents: [...],
    media_contents: [               -- 新增可选字段 (Expand 兼容变更)
      {
        media_id: UUID,             -- 外部统一用 media_id
        text_fallback: str,
        associated_entity_id: str,   -- 关联的图谱实体
        content_type: "product_image" | "brand_guideline" | "training_video" | ...
      }
    ],
    org_context: {...},
    metadata: {...}
  }
```

---

### Layer 4: Skill 层 (03-Skill层.md)

#### 3.13 SkillProtocol 扩展

```
SkillProtocol 扩展:
  现有 capabilities: Set[str] 新增枚举值:
    "multimodal_input"   -- Skill 可处理多模态输入
    "multimodal_output"  -- Skill 可生成多模态输出

  现有 optional_tools 扩展:
    ContentWriterSkill.optional_tools: ["image_generate"] (已存在于 03-Skill层.md:134)
    新增: ["image_analyze", "audio_transcribe", "document_extract"]

  向后兼容:
    无 multimodal_input/output 能力的 Skill 行为不变
    Brain Skill Router 仅在用户输入包含 ContentBlock (type!=text) 时
    才将 multimodal 能力作为路由条件
```

---

### Layer 5: Tool 层 (04-Tool层.md)

#### 3.14 Tool 清单扩展

```
Tool 清单更新:
| Tool            | 状态   | 说明           | 计费    |
|-----------------|--------|---------------|---------|
| LLMCall         | Day 1  | 统一 LLM 入口  | 按 Token |
| ImageGenerate   | M1     | 图片生成       | 按张     |
| ImageAnalyze    | M1     | 图片理解       | 按 Token |
| AudioTranscribe | M1     | 语音转文字     | 按分钟   |
| DocumentExtract | M2     | 文档解析       | 按次     |
| WebSearch       | 占位   | 联网搜索       | 按次     |
| WebScrape       | 占位   | 网页抓取       | 按次     |
| CodeSandbox     | 占位   | 代码执行       | 按次     |
| ExternalAPI     | 占位   | 外部系统对接   | 按次     |

Tool 计量 (对齐 04-Tool层.md:78-93):
  每次调用写入 tool_usage_records (非 llm_usage_records)
  字段对齐: tool_name, tool_version, org_id, user_id, skill_id,
           input_summary(脱敏), duration_ms, cost_amount, status
```

---

### Layer 6: Gateway 层 (05-Gateway层.md)

#### 3.15 WS 消息类型: 保留现有命名，扩展 payload

```
WS 下行消息类型 (保持 frontend_design.md:549-551 契约):
  ai_response_chunk:
    v0 (旧客户端): {text: "...", ...}
    v1 (新客户端): {text: "...", blocks: [ContentBlock], content_version: 1}
    向后兼容:
      缺失 content_version 或缺失 blocks -> 纯文本模式 (与现有行为一致)
      有 blocks + content_version: 1 -> 前端按 ContentBlock 渲染

  tool_output: (无需修改)
    现有已支持结构化 JSONB，Component Registry 按 type 渲染
    多模态 Tool 结果自然通过 tool_output 下发
    前端 Component Registry 新增 media 类型渲染器即可

  task_complete: (无需修改)
    含 task_id + result，多模态任务结果包含在 result 中

  禁止新增: assistant_chunk / assistant_complete (v1/v2 错误命名，v3 废弃)

WS 上行消息类型扩展:
  user_message:
    v0 (旧客户端): {text: "...", session_id: "..."}
    v1 (新客户端): {text: "...", blocks: [ContentBlock], content_version: 1, session_id: "..."}
    向后兼容: 缺失 blocks -> 纯文本消息 (与现有行为一致)
```

#### 3.16 REST API 端点设计: 双路分离

```
个人媒体 API (SSOT-A 域):
  POST   /api/v1/media/upload/init          -- 初始化上传
  POST   /api/v1/media/upload/complete       -- 确认上传完成
  GET    /api/v1/media/{media_id}/url        -- 获取临时访问 URL (短 TTL)
  DELETE /api/v1/media/{media_id}            -- 个人媒体删除

  权限: user_id + tenant_id 级别 (与 memory_items 对齐)
  认证: 用户 Token

企业媒体 API (SSOT-B 域):
  POST   /api/v1/admin/knowledge/media/upload/init
  POST   /api/v1/admin/knowledge/media/upload/complete
  GET    /api/v1/admin/knowledge/media/{media_id}/url
  DELETE /api/v1/admin/knowledge/media/{media_id}

  权限: org_id + role 级别 (与 Knowledge Write API ACL 对齐)
  认证: Admin Token + ACL 校验
  路径前缀: /admin/knowledge/ 标识属于 SSOT-B 管理域
```

#### 3.17 三步上传协议 -- 安全检查时序表

```
Step 1: init (文件未上传)
  可做:
    +-- MIME type 白名单预校验 (基于客户端声明的 Content-Type)
    +-- 文件大小上限预校验 (基于客户端声明的 size)
    +-- org_tier 权限校验 (该组织是否有多模态能力)
    +-- 配额预扣 (乐观预占存储配额, quota_reserved_bytes = size)
    +-- 客户端声明 checksum_sha256, 服务端记录 expected_checksum_sha256
  不可做:
    -- 无法做 AV 扫描 (文件不存在)
    -- 无法做 EXIF 清洗 (文件不存在)
    -- 无法做 magic bytes 校验 (文件不存在)
  产出:
    +-- 创建 media record: security_status = 'pending'
    +-- 返回 presigned upload URL (带 TTL, 含 x-amz-checksum-sha256 条件)
    +-- 写入 media_event (media.upload_initiated)

Step 2: 客户端直传 (S3 presigned URL)
  S3 层面执行:
    +-- Content-Length 限制 (presigned URL 中编码)
    +-- Content-Type 限制 (presigned URL 中编码)
    +-- x-amz-checksum-sha256 原生校验 (不匹配直接 400)
  应用层:
    -- 无感知，无法介入

Step 3: complete (文件已在 S3)
  必做 (同步, 阻断返回):
    +-- checksum 校验: HeadObject 获取 x-amz-checksum-sha256 vs expected
    +-- magic bytes 校验: 读取文件头验证实际类型 vs 声明类型
    +-- 文件大小实际值校验 vs init 时声明值
    +-- EXIF/元数据清洗: 移除隐私数据，覆写原文件
    +-- 快速 AV 扫描 (ClamAV 本地, < 5s 对于常见体积)
    +-- 配额确认: 实际 size <= 预扣 -> 返还差额; 超出 -> 补扣或 reject
    +-- 校验通过: security_status -> 'safe'
    +-- 校验失败: security_status -> 'rejected', 删除 S3 对象, 返还配额, 返回 4xx
  产出:
    +-- 更新 media record: security_status, scan_result
    +-- 写入 media_event (media.upload_completed 或 media.rejected)

Checksum 校验规范 (LAW, ADR-052):
  禁止使用 ETag 做完整性校验 (ETag 在 multipart 场景下不是文件 hash)
  使用 S3 原生 x-amz-checksum-sha256 (S3 从 2022 起支持)
  分片上传兼容: 每个 part 携带 checksum, CompleteMultipartUpload 时 S3 计算整体

超时回收机制:
  触发条件: security_status = 'pending' AND created_at < now() - interval '1 hour'
  执行步骤:
    1. S3 HeadObject 检查文件是否已上传 -> 已上传则删除
    2. 返还配额: quota_reserved_bytes -> 0
    3. 更新 media record: security_status -> 'expired'
    4. 写入 media_event (media.upload_expired)
  定时任务频率: 每 15 分钟
  幂等性: 仅处理 status = 'pending' 的记录
```

#### 3.18 LLM Gateway / Model Registry 扩展

```
ModelDefinition (05-Gateway层.md:136-143) 已有 capabilities 含 "vision"/"multimodal"
无需修改 Model Registry 结构，仅需:
  +-- 注册多模态模型实例
  +-- 模型访问控制: 通过 org_settings.model_access.allowed_models 管控
  +-- 模型选择: Brain 在 Generation 阶段根据输入是否含非 text ContentBlock
      优先选择具备 "vision"/"multimodal" capability 的模型
  +-- 降级: 无多模态模型可用时 -> 使用 text_fallback, 记录 degraded_reason
```

#### 3.19 LLMCallPort 签名迁移计划

```
LLMCallPort 现有签名:
  async call(prompt: str, model_id: str, ...) -> LLMResponse

扩展签名 (Expand 阶段):
  async call(
    prompt: str,                         -- 保留，向后兼容
    model_id: str,
    content_parts: Optional[List[ContentBlock]] = None,  -- 新增可选参数
    ...
  ) -> LLMResponse

  调用方行为:
    纯文本: call(prompt="...", model_id="...")           -- 与现有一致
    多模态: call(prompt=text_fallback, model_id="...",
                content_parts=[ContentBlock,...])       -- 新调用方式

  LLMCallPort 实现逻辑:
    content_parts 为 None -> 按现有 prompt-only 逻辑
    content_parts 非 None -> 组装多模态 payload:
      - 对每个 ContentBlock.media_id 查表获取 ObjectRef
      - 生成临时 presigned URL
      - 构建 provider-specific 格式 (OpenAI content array / Anthropic content blocks)
      - text_fallback 用于日志和降级

  Expand-Contract 时间线:
    Expand:   v1.x 新增 content_parts 可选参数, 默认 None
    Migrate:  v1.x+1 起 Skill 按需使用。Brain 在检测到多模态输入时使用。
    Contract: v2.0 (最小 2 minor versions 后) 评估是否将 prompt 合并入 content_parts。
```

---

## 四、横切关注点: 安全管线

```
两阶段安全管线 (非独立层，横切 Gateway/Tool/基础设施):

Stage 1 - 同步预检 (Gateway 层, complete 阶段):
  +-- magic bytes 校验 (实际类型 vs 声明类型)
  +-- 文件大小实际值校验
  +-- EXIF/元数据清洗 (移除 GPS、设备信息等隐私数据)
  +-- 快速 AV 扫描 (ClamAV 本地)
  +-- 通过: security_status -> 'safe'
  +-- 失败: security_status -> 'rejected', 删除 S3 对象

Stage 2 - 异步深度扫描 (基础设施层, Celery Worker):
  +-- NSFW 内容检测
  +-- PII 检测 (身份证号、人脸等)
  +-- 版权风险检测 (可选, M3)
  +-- 结果更新 scan_result JSONB
  +-- 风险项 -> security_status = quarantined, 通知管理员

OCR/ASR 输出清洗 (Brain 层, Context Assembler):
  +-- 多模态 Tool 的文本输出在注入 Context 前
      必须通过 Step 1.5 Sanitization
  +-- 流程: Tool output -> text_result -> Sanitization -> Context
  +-- 不新建清洗管线，复用 Step 1.5 的 Pattern-based + LLM-based 双重清洗

security_status 三层拦截 (LAW):

  Layer 1 - Gateway (取 URL 时):
    GET /api/v1/media/{media_id}/url 和 /admin/knowledge/ 对应端点
      safe -> 生成 presigned download URL, 返回
      pending | scanning -> 403 + error: "media_processing"
      rejected -> 404 (视为不存在)
      quarantined -> 403 + error: "media_quarantined"
      expired -> 404

  Layer 2 - Brain (写入 conversation_events 时):
    对 ContentBlock 中每个 media_id:
      查 security_status, 非 safe -> 拒绝整条消息, 返回错误
    目的: 防止不安全媒体进入对话历史

  Layer 3 - LLMCallPort 实现 (构建 LLM payload 前):
    对 content_parts 中每个 media_id:
      查 security_status, 非 safe -> 替换为 text_fallback
      记录 degraded_reason: "media_security_blocked"
    目的: 防止不安全媒体发送给 LLM provider

  异步降级处理 (quarantined 后):
    已写入 conversation_events 的 ContentBlock 引用了后来被 quarantined 的 media_id:
      前端下次请求该消息时走 Layer 1 被拦截 -> 降级展示 text_fallback
      不修改已写入的 conversation_events 数据 (append-only 原则)

媒体安全状态机 (ADR-051):
  pending -> safe         [complete 通过所有同步检查]
  pending -> rejected     [complete 同步检查失败]
  pending -> expired      [超时未 complete, 定时任务回收]
  safe -> quarantined     [异步深度扫描检出风险]
  quarantined -> safe     [管理员放行]
  quarantined -> rejected [管理员拒绝或超期未审核]
```

---

## 五、横切关注点: 可观测性

```
多模态可观测性扩展 (非独立层，横切所有层):

计量 (基础设施层):
  tool_usage_records: 每次多模态 Tool 调用记录
  media_event: 媒体生命周期事件 (上传/扫描/删除/超时)
  llm_usage_records: 多模态模型的 token 消耗 (现有机制，仅模型实例变化)

计费反压 Loop D 扩展 (Pre-check + Post-settle):
  Pre-check 扩展:
    现有: 检查 budget_monthly_tokens
    新增: 检查 budget_tool_amount (工具费用预算)
    实现: Gateway 在路由到多模态 Skill 前，同时校验 token 和 tool 两个维度
    任一耗尽 -> 402 拒绝

  Post-settle 扩展:
    现有: LLM 响应后异步扣减 token
    新增: Tool 执行后异步扣减 tool cost
    实现: tool_usage_records 写入后触发 budget_tool_amount 扣减
    即将耗尽(< 10%): 返回 X-Tool-Budget-Remaining 告警头

监控:
  +-- 媒体上传成功率 / 安全拒绝率 / 超时过期率
  +-- 多模态 Tool 调用延迟 P50/P99
  +-- Object Storage 存储量 / 带宽 (按 org_tier 统计)
  +-- 安全扫描队列深度和处理延迟
  +-- 配额预扣 vs 实际使用偏差率
```

---

## 六、删除管线: 完整覆盖矩阵

```
删除触发源:
  1. 用户删除请求 (personal_media, 遵循 tombstone 状态机)
  2. 管理员删除请求 (enterprise_media, 遵循 Knowledge Write API ACL)
  3. PIPL/GDPR 合规删除 (按 legal_profile SLA)
  4. 安全扫描拒绝后自动删除 (quarantined media 超期未审核)

--- personal_media 删除管线 (SSOT-A, tombstone) ---

  Step 0: 意图记录
    +-- 写入 tombstone 记录 (状态: requested)
    +-- 记录: 删除意图、用户 ID、影响范围
    +-- 写入 media_event (media.deletion_requested, domain="personal")

  Step 1: 权限验证
    +-- user_id 匹配
    +-- tombstone 状态: requested -> verified

  Step 2: 级联删除执行 (原则: 可逆操作先行，不可逆操作最后)
    +-- PG: personal_media_objects 关联 tombstone_id (软删标记, 可逆)
    +-- Redis: 清除相关缓存
    +-- CDN: purge
    +-- Object Storage: 删除原始文件 + 衍生文件 (物理删除, 不可逆, 最后执行)
    +-- progress JSONB 逐项更新 (复用 tombstone.progress 机制)
    +-- tombstone 状态: verified -> queued -> processing

  Step 3: 完成确认
    +-- 所有存储位置确认清除
    +-- 写入 media_event (media.deletion_completed, domain="personal")
    +-- tombstone 状态: processing -> completed

--- enterprise_media 删除管线 (SSOT-B, ChangeSet) ---

  Step 0: ACL 校验 + ChangeSet 记录
    +-- 校验: 操作者角色 + 组织范围 (02-Knowledge层.md:429)
    +-- 创建 ChangeSet: 记录删除意图、操作者、影响范围
    +-- 写入 media_event (media.deletion_requested, domain="enterprise")

  Step 1: 级联执行 (原则: 可逆操作先行，不可逆操作最后; FK 顺序遵循 02-Knowledge层.md:503-506)
    +-- PG: enterprise_media_objects 设 deleted_at + deletion_changeset_id (软删标记, 可逆)
    +-- Qdrant: 先批量删除含该 graph_node_id 的向量条目 (Qdrant-first, FK 协议)
    +-- Neo4j: 再通过 ChangeSet 更新/删除关联节点/边
    +-- Redis: 清除相关缓存
    +-- CDN: purge
    +-- Object Storage: 删除原始 + 衍生文件 (物理删除, 不可逆, 最后执行)
    容错: Qdrant 删除失败 -> Neo4j 节点标记 sync_status = "pending_vector_delete"
          Reconciliation Job 后续补删 (复用 02-Knowledge层.md:496-500 自愈机制)
    设计依据: PG 软删后 Gateway 层即返回 404，用户侧立即不可见;
             即使后续步骤部分失败，不会出现"文件已删但索引仍指向"的破链中间态

  Step 2: 确认
    +-- ChangeSet 状态更新为 completed
    +-- 写入 media_event (media.deletion_completed, domain="enterprise")

--- 双管线区别 ---
  personal: tombstone 8 态状态机, legal_profile SLA, 用户自助
  enterprise: ChangeSet + ACL, 管理员操作, 无 PIPL/GDPR SLA (企业自有资产)

失败处理 (两条管线共用):
  +-- 任一存储位置失败: 进入重试
  +-- 重试策略: 指数退避, 上限 5 次
  +-- 重试耗尽: P0 告警 + 人工介入
```

---

## 七、ObjectStoragePort (新增 Port 契约)

```python
class ObjectStoragePort:
    """对象存储抽象接口，底层可替换 (S3/MinIO/OSS)"""

    async def generate_upload_url(
        self, bucket: str, key: str, mime_type: str,
        max_size: int, checksum_sha256: str,
        expires_in: int = 3600
    ) -> PresignedUploadURL

    async def generate_download_url(
        self, bucket: str, key: str, expires_in: int = 900
    ) -> PresignedDownloadURL

    async def delete_object(self, bucket: str, key: str) -> None

    async def delete_objects(self, bucket: str, keys: List[str]) -> BatchDeleteResult

    async def head_object(self, bucket: str, key: str) -> ObjectMetadata

    # Port 边界: 不含业务逻辑、安全扫描、权限校验
    # 仅提供存储操作原语
```

---

## 八、5 条 Loop 影响矩阵

| Loop | 影响级别 | 具体变化 | 变更层级 |
|------|---------|---------|---------|
| A: 学习进化 | Medium | Memory Core 需存储多模态 conversation_events (ContentBlock); 进化引擎需评估图片/音频内容是否可提升为组织知识; Promotion Pipeline 需处理 media_id 的脱敏 (移除个人媒体引用) | Brain + Memory Core |
| B: 知识沉淀 | High | Knowledge Write API 新增媒体写入管线; FK 联动扩展到 enterprise_media_objects; KnowledgeBundle schema 新增 media_contents; Resolver 需索引媒体元数据 | Gateway + Knowledge |
| C: 知识消费 | High | Skill 需处理多模态输入/输出; Resolver 返回 KnowledgeBundle 含 media_id; LLMCallPort 扩展 content_parts; Brain 在 Generation 阶段需选择多模态模型 | Brain + Skill + Tool + Knowledge |
| D: 计量反压 | Medium | Pre-check 扩展 budget_tool_amount 维度; Post-settle 扩展 tool_usage_records 扣减; X-Tool-Budget-Remaining 告警头 | Gateway + 基础设施 |
| E: 治理闭环 | Low | org_settings 新增媒体相关配置 (file_size_limit, allowed_media_types, media_quota); Settings 继承链对多模态配置生效; RLS 策略新增两张媒体表 | 基础设施 |

---

## 九、ADR 清单

| ADR | 标题 | 决策摘要 |
|-----|------|---------|
| ADR-043 | ContentBlock Schema v1.1 | 统一多模态内容模型; text_fallback 必填; 外部统一 media_id, 存储层内部 ObjectRef; 禁止存储临时 URL |
| ADR-044 | 双域媒体存储 | personal_media_objects (SSOT-A, tombstone) + enterprise_media_objects (SSOT-B, ChangeSet); 各自独立 RLS; enterprise 不引用 tombstone |
| ADR-045 | 三步上传协议 | init -> 客户端直传 -> complete; 每步安全检查范围明确; complete 后阻断规则; 配额预扣+超时回收 |
| ADR-046 | LLMCallPort Expand 迁移 | content_parts 可选参数; Expand-Contract 三阶段; 最小 2 minor versions 兼容期 |
| ADR-047 | Tool 独立计费 | tool_usage_records 与 llm_usage_records 分离; Loop D Pre-check 覆盖双维度 |
| ADR-048 | 媒体删除完整性 | Step 0 意图记录不可跳过; personal 走 tombstone, enterprise 走 ChangeSet; 覆盖原始/衍生/CDN/向量/图谱/缓存 |
| ADR-049 | Tier 命名一致性修正 | 06-基础设施层.md line 263 DEFAULT 值对齐 Section 1.1; M0 实际落地修正 |
| ADR-050 | 版本号三层分离 | DB 行级 / WS 消息级 / 事件级三层; content JSONB 内禁放版本号; 三层互不依赖 |
| ADR-051 | 媒体安全状态机 | 6 态 (pending/scanning/safe/rejected/quarantined/expired); 三层拦截 (Gateway/Brain/LLMCallPort) |
| ADR-052 | Checksum 校验规范 | 禁止 ETag; 使用 S3 原生 x-amz-checksum-sha256; 分片上传兼容 |

---

## 十、实施分期

### M0: 基座期 (无用户可见变化)

- ContentBlock Schema v1.1 定义 + JSON Schema 验证
- ObjectStoragePort 接口 + S3/MinIO 实现
- personal_media_objects / enterprise_media_objects DDL + RLS
- tool_usage_records DDL
- conversation_events.content_schema_version 列
- usage_budgets.budget_tool_amount 列
- event_outbox 注册 media_event 类型 (含 idempotency_key 规范)
- LLMCallPort content_parts 可选参数 (Expand)
- 安全管线 Stage 1 (同步预检)
- 配额预扣 + 超时回收定时任务
- ADR-049 tier 命名修正 + max_org_depth
- 契约测试: Layer 1-4 全量新增条目 (见 Section 十二)

### M1: 个人多模态 (用户可发送/接收图片和语音)

- 个人媒体上传 API (三步协议, S3 原生 checksum)
- WS ai_response_chunk / user_message payload 扩展 (blocks + content_version)
- ImageAnalyze Tool + ImageGenerate Tool + AudioTranscribe Tool
- Brain Generation 阶段多模态模型选择逻辑
- Context Assembler Step 1.5 覆盖 OCR/ASR 输出
- Loop D Pre-check 扩展 budget_tool_amount
- security_status 三层拦截实现
- 安全管线 Stage 2 (异步深度扫描)
- 个人媒体删除管线 (tombstone + 全覆盖)

### M2: 企业多模态 (知识库支持媒体资产)

- 企业媒体上传 API (三步协议, /admin/knowledge/ 路径)
- KnowledgeBundle media_contents 扩展
- enterprise_media_objects 与 Neo4j FK 联动
- Qdrant 向量 payload media_refs 扩展
- 应用层 visibility 继承过滤 (复用 Resolver 逻辑)
- Skill multimodal_input/output 能力声明
- DocumentExtract Tool
- 企业媒体删除管线 (ChangeSet + 图谱级联)
- Promotion Pipeline 多模态脱敏

### M3: 成熟期

- 版权风险检测
- 视频流式处理
- 跨模态语义检索
- LLMCallPort Contract 阶段评估

---

## 十一、LAW/RULE/BRIDGE 约束分类

```
LAW (系统不变量，硬编码):
  - 外部接口禁止暴露 ObjectRef (bucket/key), 统一使用 media_id
  - ObjectRef 禁止持久化 presigned_url
  - personal_media_objects 与 enterprise_media_objects 物理隔离
  - enterprise_media 删除走 ChangeSet，禁止引用 tombstone
  - enterprise 删除顺序: Qdrant-first -> Neo4j (02-Knowledge层.md FK 删除一致性协议)
  - 删除 Step 0 意图记录不可跳过
  - 安全扫描 Stage 1 (同步预检) 不可旁路
  - security_status != 'safe' 的 media_id 不可被 ContentBlock 引用 (三层拦截)
  - content JSONB 内禁止放版本号 (三层分离原则)
  - 禁止使用 ETag 做完整性校验 (S3 原生 checksum)
  - idempotency_key 禁止包含 timestamp (同一业务动作重试时 key 必须相同)
  - PG/Neo4j/Qdrant 异构存储禁止假设分布式事务，必须走 outbox + FK 协议最终一致性
  - 删除管线不可逆操作 (Object Storage 物理删除) 必须排在最后，PG 软删标记先行

RULE (可配置策略):
  - 文件大小限制 (per org_tier)
  - 允许的 MIME 类型白名单 (per org_settings)
  - 媒体存储配额 (per org)
  - NSFW 检测灵敏度阈值
  - 异步深度扫描 quarantined 超期天数 (默认 7 天)
  - init 配额预扣超时回收间隔 (默认 1 hour)
  - 超时回收定时任务频率 (默认 15 分钟)

BRIDGE (继承锁):
  - 上级 allowed_media_types 是下级上限 (与 model_access 同模式)
  - 上级 file_size_limit 若 is_locked=true，下级不可放宽
```

---

## 十二、契约测试条目清单

```
Layer 1 (Port Schema 断言测试):
  +-- ObjectStoragePort: 方法签名 (generate_upload_url, generate_download_url,
      delete_object, delete_objects, head_object) + 参数类型 + 返回类型
  +-- LLMCallPort.call(): content_parts 可选参数类型断言
      (List[ContentBlock] | None, Expand 兼容)
  覆盖范围: 原 6 个 Port + ObjectStoragePort = 7 个 Port

Layer 2 (语义契约 Snapshot 测试):
  +-- ContentBlock Schema v1.1: JSON Schema snapshot
      测试: 构造合法 ContentBlock (各 type) -> 序列化 -> snapshot 比对
  +-- KnowledgeBundle media_contents: JSON Schema snapshot (扩展字段)
      测试: 含 media_contents 的 KnowledgeBundle -> snapshot 比对
  +-- MultimodalMessage (WS payload): JSON Schema snapshot
      测试: ai_response_chunk 含 blocks + content_version -> snapshot 比对
  覆盖范围: 原 3 个 schema + 3 个新增 = 6 个 schema

Layer 3 (事件契约测试):
  +-- media_event (7 个子类型): 生产者构造事件 -> 断言符合消费者契约
      消费者: 安全管线 Worker (订阅 upload_completed)
              删除管线 Worker (订阅 deletion_requested)
              审计服务 (订阅所有 media_event)
              计费服务 (订阅 upload_completed, 用于存储计量)
              回收 Worker (订阅 upload_expired)
  +-- tool_usage_records 相关事件: 计费事件 payload 断言
  覆盖范围: 原 Level 1/2 事件 + media_event + tool billing event

Layer 4 (持久化数据版本兼容测试):
  +-- conversation_events: content_schema_version=0 样本 + version=1 样本
      测试: 新代码能正确解析 version=0 的纯文本 content
  +-- personal_media_objects / enterprise_media_objects: v1 样本
  +-- tool_usage_records: v1 样本
  覆盖范围: 原 memory_items/event_outbox/receipts + 新增 3 张表的 Fixture

CI 集成规则 (与现有一致):
  PR 级: Layer 1 + Layer 2 必须通过
  日构建: Layer 3 + Layer 4 完整运行
  破坏性变更: snapshot diff -> 自动标注 BREAKING CHANGE
```
