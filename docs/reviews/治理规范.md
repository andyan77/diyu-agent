> [状态说明] 本文为历史收敛稿（含讨论草案与增强想法）。
> v1.1 可执行基线请使用：`reviews/治理规范.v1.1-正文.md` 与 `reviews/治理规范.v1.1-Vibe执行附录.md`。

笛语 Agent 项目构建规范、纪律与流程方案 V1.0
版本: 1.0 Final
日期: 2026-02-12
状态: 经多轮审阅收敛定版
适用范围: 笛语 Agent 全系统研发构建 + 交付产品化

〇、方案定位
本方案覆盖两个维度：

维度	管什么	成熟度
研发治理	怎么写代码、怎么测试、怎么合并、怎么发布	Phase 0 全量落地
交付产品化	怎么安装、怎么升级、怎么备份恢复、怎么支持客户	Phase 0 建骨架，Phase 3-4 填实值
一、三 SSOT 治理体系
┌─────────────────────────────────────────────────────────────────────┐
│                                                                     │
│  SSOT-1: 决策 SSOT                                                  │
│  ════════════════                                                   │
│  位置: docs/architecture/*.md + docs/adr/*.md                       │
│  管什么: 架构决策、约束等级(LAW/RULE/GUIDE)、层间契约语义            │
│  谁改: 架构负责人审批                                                │
│  原则: 先改文档再改代码，不允许代码领先于文档                         │
│                                                                     │
│  SSOT-2: 运行契约 SSOT                                              │
│  ══════════════════                                                  │
│  位置: src/ports/ + migrations/ + OpenAPI spec                      │
│  管什么: Port 接口签名、数据库 Schema、API 端点定义                  │
│  谁改: PR 流程，触发 [CONTRACT] / [MIGRATION] 标记时额外审查         │
│  原则: 代码变更时同步更新                                            │
│                                                                     │
│  SSOT-3: 交付 SSOT                                                  │
│  ════════════════                                                   │
│  位置: delivery/manifest.yaml                                       │
│  管什么: 组件清单、版本矩阵、端口、健康检查、升级约束、备份策略       │
│  谁改: DevOps + 架构负责人                                          │
│  原则: Phase 0 建骨架(Schema先行,值标TBD), Phase 3-4 回填实值,       │
│        GA 前冻结。所有 Compose/Helm/Ansible 从此文件读取或生成。      │
│                                                                     │
│  一致性检查（CI 中运行，阻断发版不阻断 PR）:                        │
│  ├── Port 接口签名 ↔ 架构文档中契约定义 → 偏差告警                  │
│  ├── Migration 最新 Schema ↔ 文档中 DDL 定义 → 偏差告警             │
│  └── docker-compose.yml ↔ delivery/manifest.yaml → 偏差告警         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
二、项目目录结构
diyu-agent/
├── docs/
│   ├── architecture/          # 决策 SSOT
│   ├── adr/                   # Architecture Decision Records
│   └── api/                   # API 文档（OpenAPI spec 自动生成）
│
├── src/
│   ├── brain/                 # Layer 1: 对话 Agent 层
│   │   ├── engine/            #   对话引擎 + 意图理解
│   │   ├── memory/            #   记忆引擎（Evolution Pipeline）
│   │   ├── context/           #   Context Assembler
│   │   └── ports/             #   Port 实现（Adapter）
│   │
│   ├── knowledge/             # Layer 2: Knowledge 层
│   │   ├── resolver/          #   Diyu Resolver
│   │   ├── registry/          #   实体类型注册
│   │   ├── write_api/         #   Knowledge Write API
│   │   └── ports/             #   Port 实现（Adapter）
│   │
│   ├── skill/                 # Layer 3: Skill 层
│   │   ├── core/              #   SkillProtocol 基类
│   │   ├── content_writer/    #   内容写手 Skill
│   │   └── merchandising/     #   商品搭配 Skill
│   │
│   ├── tool/                  # Layer 4: Tool 层
│   │   ├── core/              #   ToolProtocol 基类
│   │   ├── llm_call/          #   LLMCall Tool
│   │   └── adapters/          #   外部 API 适配器
│   │
│   ├── gateway/               # Layer 5: Gateway 层
│   │   ├── api/               #   FastAPI 路由
│   │   ├── middleware/        #   认证/鉴权/OrgContext 中间件
│   │   ├── ws/                #   WebSocket 管理
│   │   └── media/             #   三步上传协议
│   │
│   ├── infra/                 # Layer 6: 基础设施层
│   │   ├── org/               #   组织模型 + RBAC
│   │   ├── db/                #   数据库连接 + Migration
│   │   ├── storage/           #   ObjectStoragePort 实现
│   │   ├── event/             #   事件总线 + Outbox
│   │   └── observability/     #   指标 + 链路追踪
│   │
│   ├── ports/                 # 公共 Port 接口定义（跨层共享）
│   │   ├── memory_core_port.py
│   │   ├── knowledge_port.py
│   │   ├── llm_call_port.py
│   │   └── object_storage_port.py
│   │
│   └── shared/                # 公共类型、常量、工具函数
│       ├── types/             #   OrganizationContext, KnowledgeBundle 等
│       ├── errors/            #   统一异常体系
│       └── utils/
│
├── tests/
│   ├── unit/                  # 单元测试（镜像 src/ 结构）
│   ├── integration/           # 集成测试（跨层调用）
│   ├── isolation/             # 租户隔离专项测试
│   │   └── smoke/             #   隔离 smoke 子集（硬门禁用，< 30秒）
│   └── fixtures/              # 测试夹具 + 工厂
│
├── migrations/                # Alembic 数据库迁移
├── scripts/                   # Guard 脚本 + 运维脚本
│   ├── check_layer_deps.sh
│   ├── check_rls.sh
│   ├── check_port_compat.sh
│   ├── check_migration.sh
│   └── change_impact_router.sh
│
├── delivery/                  # 交付 SSOT
│   ├── manifest.yaml          #   交付契约（组件/版本/端口/约束）
│   └── preflight.sh           #   安装前置检查脚本
│
├── deploy/                    # 部署配置
│   ├── docker-compose.yml
│   ├── docker-compose.dev.yml
│   └── k8s/                   #   Phase 3+ Helm Chart
│
├── .github/                   # CI/CD 配置
├── .claude/skills/            # AI 辅助 Skill (迁移自 .agent/workflows/, ADR-053)
├── pyproject.toml
├── Makefile
└── .env.example
目录铁律
规则	说明
Port 定义集中在 src/ports/	各层 ports/ 放具体 Adapter 实现
层间依赖单向	brain → knowledge → skill → tool，禁止反向 import
shared/types/ 是契约边界	OrganizationContext, KnowledgeBundle, MemoryItem 等必须定义在此
每个模块有 __init__.py	显式控制公开 API，禁止 from module import *
delivery/manifest.yaml 是交付唯一真源	Compose/Helm/Ansible 从此读取或生成，不独立硬编码
三、技术栈固定清单
层面	选型	版本锁定策略
语言	Python 3.12+	python_requires 锁定
Web 框架	FastAPI + Uvicorn	Major 版本锁定
ORM / 数据库	SQLAlchemy 2.0 + Alembic	Major 版本锁定
PostgreSQL	16+ (pgvector, ltree, pg_trgm)	镜像版本锁定
图数据库	Neo4j 5.x	Docker 镜像锁定
向量数据库	Qdrant 1.x	Docker 镜像锁定
对象存储	MinIO (dev) / S3 (prod)	接口兼容即可
缓存	Redis 7+	Docker 镜像锁定
异步任务	Celery + Redis Broker	Major 版本锁定
LLM SDK	LiteLLM	Minor 版本锁定
依赖管理	uv	锁定 uv.lock
测试	pytest + pytest-asyncio + hypothesis	跟随最新稳定
代码风格	ruff (lint + format)	配置锁定
类型检查	mypy (strict mode)	跟随最新稳定
四、分支策略：Trunk-Based + 短分支
main ──●──●──●──●──●──●──●──●──── 唯一长期分支，始终可部署
       │     │        │
       └─f/a─┘        └──fix/b──┘   短分支，生命周期 ≤ 3 天
规则	说明
唯一主干 main	无 develop 分支
短分支 ≤ 3 天	超过 3 天需 Owner 主动说明
合并方式	Squash Merge（主干历史线性）
大功能隔离	Feature Flag 控制，不靠长分支
Hotfix	从 main 拉分支，修复后合并回 main
分支命名
feature/<layer>-<brief>    例: feature/brain-memory-evolution-pipeline
fix/<issue-id>-<brief>     例: fix/DY-042-rls-policy-leak
hotfix/<brief>             例: hotfix/jwt-validation-bypass
refactor/<scope>-<brief>   例: refactor/knowledge-port-interface
migration/<brief>          例: migration/memory-items-add-epistemic-type
Commit 规范 (Conventional Commits)
<type>(<scope>): <description>
type: feat | fix | refactor | test | docs | chore | perf | security
scope: brain | knowledge | skill | tool | gateway | infra | ports | shared | migration | delivery
版本与发布策略
当前策略（v1.0 GA 前）：
  语义化版本号 (SemVer)
  单一稳定版本，所有客户跟 main 最新
  安全补丁: N-1 版本补丁策略
LTS 触发条件（满足任一）：
  ≥ 3 付费客户并行运行不同 minor
  监管要求固定补丁窗口
  支持团队达到多版本维护阈值
触发前不建立 LTS 体系。
五、CI 门禁：硬门禁 + 软门禁 + 发布门禁
硬门禁（PR 阻断，< 3 分钟）
□ ruff lint + format check
□ mypy --strict
□ layer-dependency-guard (scripts/check_layer_deps.sh)
□ commit message lint (Conventional Commits)
□ pytest tests/unit/
□ pytest tests/isolation/smoke/         ← 隔离 smoke 子集
□ secret scanning
□ SAST 静态安全扫描
□ 依赖漏洞扫描 (pip-audit)
软门禁（PR 合并后异步，结果通知 PR 评论区）
□ pytest tests/integration/             全量集成测试
□ pytest tests/isolation/               全量隔离测试
□ migration dry-run                     迁移可回滚验证
□ Docker 镜像构建 + 镜像安全扫描
□ SBOM 生成
发布门禁（Release 阻断）
□ 软门禁全部 PASS
□ 性能基线对比（不劣于上一版本）
□ 备份可用性演练通过
□ 跨版本恢复演练通过（Phase 4+）
□ 三 SSOT 一致性检查无偏差
□ CHANGELOG 生成
□ delivery/manifest.yaml 版本号更新
□ 迁移回滚实际演练记录存在（非"理论可回滚"）
自动变更影响路由
文件变更路径                  → 自动触发
────────────────────────────────────────────
src/ports/**                  → [CONTRACT] 标记 + Port 兼容性检查
migrations/**                 → [MIGRATION] 标记 + 回滚验证
**/rls** | **/policy**        → [SECURITY] 标记 + RLS guard
src/infra/org/**              → [SECURITY] 标记
src/gateway/middleware/**     → [SECURITY] 标记
pyproject.toml | uv.lock     → 依赖变更审查
docker-compose* | delivery/* → DevOps 审查
由 scripts/change_impact_router.sh 实现，CI 自动执行，不依赖人工判断。

六、代码审查流程
审查矩阵
变更类型	Reviewer 数	必须包含角色	SLA
普通功能	1	同层开发者	1 工作日
跨层变更	2	涉及层的各 1 位开发者	1 工作日
[CONTRACT] Port 接口	2	架构负责人 + 消费端开发者	2 工作日
[MIGRATION] 数据库	2	架构负责人 + 数据安全	2 工作日
[SECURITY] 安全相关	2	安全负责人（必须）	1 工作日
配置 / 依赖 / 交付	1	DevOps	1 工作日
超时升级机制
时间节点	动作
PR 创建	自动 assign reviewer（CODEOWNERS）
+8 小时	Bot 提醒 reviewer
+24 小时	自动升级至 backup reviewer
+48 小时	升级至 Tech Lead，标记 review-blocked
+72 小时	升级至项目负责人
审查检查清单
□ 1.  层间依赖方向正确
□ 2.  数据库查询通过 RLS 保护或注入 org_context
□ 3.  Port 接口变更遵循 ADR-033 兼容规则
□ 4.  新增 API 端点有 OpenAPI 注解
□ 5.  新增配置项有 org_settings 继承/is_locked 考量
□ 6.  测试覆盖率满足风险分层要求（见第七节）
□ 7.  无硬编码密钥/连接串
□ 8.  异步操作有幂等键 (idempotency_key)
□ 9.  错误路径有明确处理（禁止裸 except）
□ 10. 日志包含 trace_id + org_id
七、测试规范
覆盖率：风险分层
风险层级	模块范围	覆盖率	场景覆盖
🔴 Critical	RLS 策略、安全隔离、RBAC、Token 计费、Migration 路径、删除管线	≥ 95%	正向 + 反向 + 边界 + 竞态
🟠 High	Port 接口、Memory Core CRUD、知识写入管线、FK 一致性、OrgContext	≥ 85%	正向 + 反向 + 边界
🟡 Medium	Brain 对话引擎、Resolver、Skill 调度、Context Assembler	≥ 70%	正向 + 主要反向
🟢 Low	适配层、日志、工具函数、配置加载	≥ 50%	正向即可
测试策略矩阵
测试类型	适用模块	运行时机
单元测试	所有模块	每次 commit（硬门禁）
隔离 Smoke	租户隔离核心路径	每次 commit（硬门禁）
全量隔离测试	租户隔离全场景	PR 合并后（软门禁）
集成测试	跨层调用链	PR 合并后（软门禁）
反向测试	RLS — assert 租户 A 读不到租户 B	每次 commit（隔离 smoke）
Property-based	RLS — hypothesis 生成随机 org_path 组合	每日定时
故障注入	删除管线 — tombstone 每步注入失败	发版前
恢复演练	Migration upgrade → downgrade → upgrade 循环（带数据）	发版前
定点 Mutation	纯算法模块（计费计算、预算分配）	夜间/发版前
性能基线	端到端对话延迟、检索 P95	发版前
隔离测试铁律
python
class TestTenantIsolation:
    """零容忍，100% PASS 才能合并"""
    def test_memory_items_isolation(): ...
    def test_knowledge_stores_isolation(): ...
    def test_org_tree_boundary(): ...
    def test_rls_bypass_attempt(): ...
    def test_media_presigned_url_isolation(): ...
    def test_cross_brand_knowledge_leak(): ...
测试命名规范
python
def test_<被测单元>_<场景>_<预期结果>():
    """中文描述：测试意图说明"""
八、数据库 Migration 纪律
#	原则
1	每个迁移必须可回滚：upgrade() 和 downgrade() 成对
2	禁止破坏性变更一步到位：必须走 Expand-Migrate-Contract 三阶段（ADR-034）
3	新增列必须有 DEFAULT 或 NULLABLE
4	禁止在迁移中做数据转换（用独立脚本）
5	RLS 策略变更必须附带隔离测试
6	迁移文件名包含 ADR 编号
7	发版前必须有实际执行的 upgrade → downgrade 演练记录
Expand-Migrate-Contract 示例
Phase 1 (Expand):  新增列 (nullable)，Port 接口同时接受新旧字段名
Phase 2 (Migrate): 回填数据，逐模块切换，CI lint 禁止新增旧字段引用
Phase 3 (Contract): 新列改 NOT NULL，移除兼容别名
九、失败恢复设计基线
机制	规范要求	落地 Phase
Outbox 投递	Level 1 关键事件走 event_outbox + poller，at-least-once	0
幂等键	所有异步操作必须有 idempotency_key，消费端 inbox 去重	0
死信处理	Worker 重试 5 次（指数退避）→ 死信队列 → P0 告警 + 人工介入	1
补偿流程	FK 一致性失败 → sync_status 标记 → Reconciliation Job 自愈	1
迁移回滚	每条 Migration 有实际执行过的 downgrade() 演练记录	0
部署回滚	前一版本镜像保留 ≥ 3 个，回滚 < 5 分钟	0
十、数据生命周期治理
数据类型	活跃保留	归档策略	硬删除窗口	审计追踪
conversation_events	90 天	冷归档至 S3	归档 2 年后物理删除	保留事件骨架
memory_items	永久	不归档	tombstone SLA ≤ 15 工作日	tombstones + audit_events
audit_events	≥ 3 年	1 年后冷归档	不删除	自身即审计
llm_usage_records	6 个月	冷归档	2 年后	usage_daily_summaries
content_tasks	1 年	冷归档	3 年后	audit_events
Object Storage	S3 Lifecycle: 90天→IA, 1年→Glacier	自动	关联实体删除时级联	media_event
十一、交付产品化治理
11.1 Delivery SSOT Skeleton
Phase 0 创建 delivery/manifest.yaml，定义字段与约束，值标 TBD：

yaml
# delivery/manifest.yaml — Delivery SSOT
components:
  api:
    image: diyu/api
    version: TBD
    port: 8000
    health_check: /healthz
    depends_on: [postgres, redis]
    resources: { cpu: TBD, memory: TBD }
    upgrade_pre_check: [migration_compatible, config_schema_compatible]
    plane: [CP, DP]
  postgres:
    image: pgvector/pgvector:pg16
    version: "16"
    port: 5432
    extensions: [pgvector, ltree, pg_trgm]
    health_check: pg_isready
    backup: { method: TBD, rpo: TBD, rto: TBD }
    resources: { cpu: TBD, memory: TBD, storage: TBD }
    plane: [CP, DP]
  neo4j:
    image: neo4j
    version: "5.x"
    port: 7687
    health_check: /db/neo4j/cluster/available
    soft_dependency: true
    resources: TBD
    plane: [DP]
  qdrant:
    image: qdrant/qdrant
    version: "1.x"
    port: 6333
    health_check: /healthz
    soft_dependency: true
    resources: TBD
    plane: [DP]
  redis:
    image: redis
    version: "7"
    port: 6379
    health_check: redis-cli ping
    resources: TBD
    plane: [DP]
  minio:
    image: minio/minio
    version: TBD
    port: 9000
    health_check: /minio/health/live
    soft_dependency: true
    resources: TBD
    plane: [DP]
  worker:
    image: diyu/worker
    version: TBD
    depends_on: [postgres, redis]
    resources: TBD
    plane: [DP]
install_constraints:
  preflight_checks:
    - docker_version: ">=24.0"
    - compose_version: ">=2.20"
    - kernel_version: ">=5.10"
    - port_availability: [8000, 5432, 7687, 6333, 6379, 9000]
    - dns_resolution: true
    - time_sync: ntp_offset < 500ms
    - disk_space_min: TBD
  idempotent: true
  offline_ready: false           # 需求触发后改 true
upgrade_constraints:
  strategy: TBD                  # Phase 3 确定: rolling | blue_green
  pre_upgrade:
    - backup_verified: true
    - migration_dry_run: pass
    - config_diff_reviewed: true
  rollback:
    max_time: TBD
    auto_trigger: health_check_fail_count >= 3
  version_compatibility:
    min_upgrade_from: TBD        # N-1 保证
    skip_version_allowed: false
backup_recovery:
  postgres: { method: TBD, rpo: TBD, rto: TBD, cross_version_tested: false }
  neo4j: { method: TBD }
  qdrant: { method: TBD }
  object_storage: { method: TBD }
diagnostic_bundle:
  includes: [logs_24h, config_sanitized, health_all, metrics_1h, trace_by_id]
  format: tar.gz
  command: "diyu diagnose --output /tmp/diyu-diag.tar.gz"
11.2 离线交付能力
Phase 0-2: "离线就绪"约束
  ✦ Docker 镜像可 docker save/load
  ✦ Python 依赖可 wheel 打包
  ✦ 不引入需要运行时外网访问的硬依赖
  ✦ delivery/manifest.yaml 标记 offline_ready: false
完整离线包（需求触发）:
  触发条件: 出现首个明确 air-gapped 客户机会单
  交付物: 离线安装包 + 私有镜像仓库同步脚本 + 离线依赖校验 + SBOM + 签名验签
  delivery/manifest.yaml 改为 offline_ready: true
11.3 安全合规交付
优先级	项目	落地时机
P0	密钥不硬编码 + TLS 强制 + 审计日志完整	Phase 0
P0	Secret scanning + SAST + 依赖漏洞扫描	Phase 0 (CI 硬门禁)
P1	密钥轮换机制 + 证书自动续期	Phase 4
P1	镜像安全扫描 + SBOM 生成	Phase 1 (CI 软门禁)
P2	审计不可篡改存储 (WORM)	有合规客户需求时
P2	漏洞修复 SLA (Critical 24-72h)	有 SLA 合同时
11.4 可运维与可支持性
Phase 4 交付:
  ✦ 一键诊断包: diyu diagnose (logs/config/health/metrics/trace)
  ✦ Runbook: 常见故障处理手册（按故障分级）
  ✦ 值班升级流程: L1(自动诊断) → L2(运维工程师) → L3(研发)
  ✦ 故障分级与 MTTR 目标:
      P0(系统不可用): MTTR < 30min
      P1(核心功能降级): MTTR < 2h
      P2(非核心功能异常): MTTR < 8h
      P3(体验问题): 下一版本修复
11.5 客户验收门禁 (SAT)
SAT 清单（种子客户验收时固化，不提前空设）:
  ✦ 安装时长: ≤ TBD 分钟（Phase 4 压测后定）
  ✦ 升级时长: ≤ TBD 分钟
  ✦ 回滚时长: ≤ TBD 分钟
  ✦ 性能基线: 对话延迟 P95 ≤ TBD
  ✦ 隔离证明: tests/isolation 全量 PASS 报告
  ✦ 审计证明: 全链路 trace_id 可追溯演示
  ✦ 备份恢复证明: 实际恢复演练记录
时机:
  Phase 2 结束: 内部 dogfooding
  Phase 3 结束: 种子用户试用
  Phase 4 结束: 制定 SAT 清单（基于真实数据）
  首个商业客户: 执行 SAT → 固化 → 后续复用
十二、Skill 组织结构（AI 辅助开发）
.claude/skills/                         # 迁移自 .agent/workflows/ (ADR-053)
├── guards/                          # 守护型（脚本化，CI 自动执行）
│   ├── layer-dependency-guard.md    #   + scripts/check_layer_deps.sh
│   ├── rls-isolation-guard.md       #   + scripts/check_rls.sh
│   ├── port-contract-guard.md       #   + scripts/check_port_compat.sh
│   ├── migration-safety-guard.md    #   + scripts/check_migration.sh
│   └── change-impact-router.md      #   + scripts/change_impact_router.sh
│
├── workflows/                       # 工作流型（统一模板，6-12 个）
│   ├── _template.md                 #   输入/前置检查/步骤/影响层/
│   │                                #   验收标准/测试清单/回滚点
│   ├── add-api-endpoint.md
│   ├── add-entity-type.md
│   ├── add-skill.md
│   ├── schema-evolution.md
│   ├── add-memory-feature.md
│   └── add-org-setting.md
│
├── patterns/                        # 模式参考（只放知识，不放流程）
│   ├── brain-layer-patterns.md
│   ├── knowledge-layer-patterns.md
│   ├── gateway-layer-patterns.md
│   └── infra-layer-patterns.md
│
└── ops/                             # 运维型
    ├── local-dev-setup.md
    ├── run-tests.md
    └── release-checklist.md
粒度控制： 工作流 6-12 个，Guard 4-8 个。规则只在一处定义，workflow 通过引用使用，杜绝重复定义漂移。Guard 的 description 写全触发语义。新增前判断是否现有 Skill 子场景。

十三、Phase 划分（终版）—— 纵向切片 + 交付交织
Phase 0 (1周): 治理最小集 + 交付骨架
──────────────────────────────────
研发:
  ✦ 项目骨架 (pyproject.toml, ruff, mypy, Makefile)
  ✦ Docker Compose 全栈环境
  ✦ PR 模板 + ADR 模板 + commit lint
  ✦ 4 个 guard 脚本雏形
  ✦ CI Pipeline 硬门禁
  ✦ 失败恢复规范 (Outbox / 幂等 / 死信)
  ✦ secret scanning + SAST + 依赖扫描接入
交付:
  ✦ delivery/manifest.yaml 骨架 (Schema 先行，值标 TBD)
  ✦ delivery/preflight.sh 雏形
验收: 空壳项目 CI 全绿，guard 脚本可执行
Phase 1 (2-3周): 安全与租户底座
───────────────────────────────
研发:
  ✦ organizations + users + org_members DDL + Migration
  ✦ OrgContext 全链路 (JWT → 中间件 → Context → RLS)
  ✦ RLS 策略基线
  ✦ RBAC 权限检查骨架
  ✦ 隔离测试框架 (tests/isolation/)
  ✦ 审计日志最小集 (audit_events)
  ✦ Port 接口定义 (空壳，签名和契约类型已定)
交付:
  ✦ 镜像安全扫描 + SBOM 接入 CI（软门禁）
验收: 两个测试租户完全隔离，隔离测试全 PASS
Phase 2 (3-4周): 首条端到端业务闭环
──────────────────────────────────
研发:
  ✦ 单一对话场景闭环:
    API/WS → Brain → Memory Core → LLMCall → 回复 → receipt → 审计
  ✦ Memory Core 完整实现 (CRUD + pgvector)
  ✦ Evolution Pipeline 最小集
  ✦ Context Assembler 基础版
  ✦ WebSocket 实时对话
交付:
  ✦ 开始记录真实资源消耗数据
  ✦ 内部 dogfooding
验收: 能实际对话、记住偏好、下次引用记忆
Phase 3 (3-4周): 知识与技能接入
────────────────────────────
研发:
  ✦ Knowledge Write API (Neo4j + Qdrant + FK 联动)
  ✦ Resolver 最小策略 (1-2 个 Profile)
  ✦ 实体类型注册机制
  ✦ Skill Protocol + content_writer Skill
  ✦ 知识驱动对话增强
交付:
  ✦ 正式建立 Delivery SSOT（Compose → 提取真实值）
  ✦ 安装器 + preflight 产品化
  ✦ delivery/manifest.yaml TBD → 实值
验收: 对话引用企业知识，能触发 Skill
Phase 4 (2-3周): 可靠性 + 可观测性 + 交付强化
──────────────────────────────────────────
研发:
  ✦ SLI/SLO 7 项指标 + Prometheus + 看板
  ✦ 全链路 trace_id + 日志标准化 + 告警
  ✦ HA 验证 (PG failover 实际演练)
  ✦ PIPL/GDPR 删除管线 (tombstone 完整)
  ✦ 故障注入测试 (删除管线每步注入失败)
  ✦ 性能基线建立
交付:
  ✦ 升级回滚流程产品化
  ✦ 备份恢复 + 演练门禁
  ✦ 一键诊断包 + Runbook
  ✦ 密钥轮换 + 证书管理
  ✦ 轻量离线 (docker save/load)
  ✦ SAT 清单制定（基于真实数据）
验收: 可监控、可告警、可故障演练、可回滚
Phase 5 (持续): 治理自动化闭环
───────────────────────────
  ✦ Guard 违规自动阻断
  ✦ 三 SSOT 自动一致性检查
  ✦ 例外审批机制
  ✦ 月度架构偏差审计
  ✦ 种子客户验收 → SAT 固化
  ✦ 按需触发: 完整离线包 / LTS 体系
十四、开发十诫
╔════════════════════════════════════════════════════════════════╗
║                    笛语 Agent 开发十诫                         ║
╠════════════════════════════════════════════════════════════════╣
║                                                                ║
║  1. 隔离是底线                                                 ║
║     RLS 和多租户隔离测试永远不可跳过。                          ║
║                                                                ║
║  2. Port 是契约                                                ║
║     跨层调用只通过 Port 接口，直接调实现 = 违规。               ║
║                                                                ║
║  3. 层间单向                                                   ║
║     上层可调下层，下层不可反向依赖上层。                        ║
║                                                                ║
║  4. 先写测试                                                   ║
║     安全/隔离/数据完整性的代码，测试先行。                      ║
║                                                                ║
║  5. 兼容变更                                                   ║
║     Port 和 Schema 变更走 Expand-Contract，禁止一步破坏。      ║
║                                                                ║
║  6. 可观测                                                     ║
║     关键操作产出回执 (receipt)，日志带 trace_id + org_id。      ║
║                                                                ║
║  7. 幂等优先                                                   ║
║     所有异步操作必须有 idempotency_key。                       ║
║                                                                ║
║  8. 配置不硬编码                                               ║
║     可变配置走 org_settings 继承链或环境变量，                  ║
║     不出现 magic number。                                      ║
║                                                                ║
║  9. 三 SSOT 同步                                               ║
║     决策文档、运行契约、交付清单三者保持一致，                  ║
║     不一致时更新源头而不是忽略差异。                            ║
║                                                                ║
║  10. 始终可部署                                                ║
║      main 任一时刻可部署、可回滚、可观测。                     ║
║      Broken build 最高优先级修复。                             ║
║                                                                ║
╚════════════════════════════════════════════════════════════════╝
十五、关键成功标准 (DoD)
✓ 任意 PR 自动判定是否触发 CONTRACT / MIGRATION / SECURITY 审查流
✓ tests/isolation 在 CI 中稳定运行且无人工豁免
✓ 所有跨层调用可追溯到 src/ports/ 契约
✓ 迁移可回滚并有实际演练记录
✓ main 任一时刻可部署、可回滚、可观测
✓ Guard 脚本化执行，非文字规范
✓ 24h 内 PR review 无响应自动升级
✓ delivery/manifest.yaml 是所有部署配置的唯一真源
✓ 备份恢复有实际演练记录，发版前通过
✓ 三 SSOT 一致性检查无偏差方可发版                                                                                                                                                                                                                                                                                                                             V1.0 → V1.1 增量变更清单
#	V1.0 状态	V1.1 变更
门禁演化	固定单层 <3min	增加运行指标触发条件（p95>5min / 排队>3min / flake>2% → 演化为 L1/L2/L3）
紧急通道	无	新增 hotfix/* + Incident ID + 24h补ADR + 逾期自动阻断 release
SSOT 漂移	仅发版阻断	PR 局部漂移检测 + accept-drift-until + 周报。[CONTRACT]/[MIGRATION]/[SECURITY] 漂移直接阻断 PR
N-1 补丁	写了策略缺工程落地	补充 release/x.y 维护分支 + 补丁窗口定义
Migration 分级	全部必须 downgrade	DDL 必须可逆 / DML forward-only + 快照。迁移元数据：reversible_type, rollback_artifact, drill_evidence_id，CI 校验
可观测性	Phase 4	Phase 0 日志标准 → Phase 1 trace + 4 黄金信号 + 基础告警 → Phase 2 看板 → Phase 4 SLO 精细化
Manifest 冻结	无 schema 校验	milestone-matrix.schema.yaml + phase_required + CI 校验。deploy/* 必须从 manifest 生成，禁止手改
备份	method: TBD	Phase 1 定方法（PG 全量+WAL/PITR），定最低演练频率，定备份加密。RPO/RTO 数值后置
供应链	Phase 1 扫描 + SBOM	Phase 2 开始生成 provenance（不阻断），Phase 3 外部交付前 cosign，Phase 4 离线包验签
例外治理	无	Exception Register（字段 + 流程 + 到期自动失效 + 月度审计）。零容忍红线：RLS / Secret / 发版SSOT
除以上 10 项增量外，V1.0 其余内容（目录结构、技术栈、分支策略、审查流程、测试分层、数据生命周期、Delivery SSOT skeleton、Phase 划分、开发十诫、DoD）原样保留。                                                                                            具体增强方案
增强 1：把 Guard 从"检查"升级为"生成阻断"
当前 Guard 是事后检查——代码写完了，CI 跑 guard 发现违规，然后让人修。对 Vibe Coder 来说，他不知道怎么修，只能再让 AI 修，可能越修越乱。

更优解：让 AI 写代码时就内置约束。

当前模式:
  Vibe Coder 让 AI 写代码 → AI 生成违规代码 → CI 拦住 → Vibe Coder 不知道怎么修
增强模式:
  Vibe Coder 让 AI 写代码 → AI 读取 patterns/ 和 guards/ 作为上下文
  → AI 生成的代码已经内置约束 → CI 验证确认
实现方式： .claude/skills/ 不只是"参考文档"，而是强制注入 AI 上下文的约束文件。每个 skill 文件中包含：

markdown
# brain-layer-patterns.md
## 强制约束（AI 必须遵守）
- 本层代码禁止 import src/gateway、src/infra、src/knowledge
- 所有数据库查询必须通过 MemoryCorePort，禁止直接写 SQL
- 所有 LLM 调用必须通过 LLMCallPort，禁止直接调 OpenAI SDK
## 代码模板
当需要新增 Memory Core 读取功能时，使用以下模板：
[具体可复制的代码模板]
## 反模式（AI 禁止生成以下代码）
❌ from src.gateway import ...
❌ import sqlalchemy; session.query(...)
❌ import openai; client.chat.completions.create(...)
这样 AI 助手在接收到约束文件后，生成的代码就已经是合规的。Guard 脚本变成了兜底验证，而不是主要防线。

增强 2：脚手架生成器代替空白创建
Vibe Coder 的典型操作是："帮我加一个新的 API 端点"。AI 可能从零开始写，漏掉 OrgContext 注入、RLS 保护、审计日志、OpenAPI 注解。

增强：提供脚手架生成命令。

bash
# 代替让 AI 从零写代码
make scaffold-api endpoint=get_recommendations module=brain
make scaffold-migration name=add_epistemic_type type=ddl
make scaffold-skill name=merchandising
make scaffold-test-isolation target=memory_items
每个脚手架自动包含：

必要的中间件注入（OrgContext、权限检查）
RLS 策略模板
审计日志桩代码
对应的测试文件骨架
OpenAPI 注解
Vibe Coder 在脚手架基础上让 AI 填充业务逻辑，比从零生成安全得多。

增强 3：增加"为什么"层（致命决策解释器）
V1.1 说"RLS 隔离测试零容忍"，传统工程师秒懂。Vibe Coder 可能想："测试老报错好烦，先跳过。"

增强：对每条零容忍规则，增加一段 30 秒能读懂的"后果说明"。

markdown
## 🔴 零容忍规则 #1：RLS 隔离测试必须 PASS
**如果你跳过这条，会发生什么：**
品牌 A 的客户登录系统后，能看到品牌 B 的所有商品数据、客户信息、销售策略。
这不是 bug，这是数据泄露事故。客户可以起诉你。
markdown
## 🔴 零容忍规则 #2：禁止直接调用 LLM SDK
**如果你跳过这条，会发生什么：**
Token 费用无法计量，月底账单可能是预期的 10 倍。
而且你无法切换 LLM 供应商，被一家锁死。
不需要写很多，每条红线规则加 2-3 行后果描述就够了。

增强 4：CI 输出人话化
当前 check_layer_deps.sh 可能输出：

ERROR: src/brain/engine/conversation.py:3 imports src.gateway.middleware.auth
Layer dependency violation detected.
Vibe Coder 看不懂。

增强：CI 错误信息附带修复指导。

❌ 层间依赖违规
   文件: src/brain/engine/conversation.py 第 3 行
   问题: Brain 层代码不允许直接引用 Gateway 层
   🔧 怎么修:
   如果你需要用户认证信息，不要 import gateway 的代码。
   认证信息已经通过 OrganizationContext 传递给你了。
   用法: def your_function(org_context: OrganizationContext)
   📖 参考: .claude/skills/ (迁移自 .agent/workflows/patterns/, ADR-053)
增强 5：Checkpoint 验证点
传统工程师可以自己判断"Phase 1 做完了没有"。Vibe Coder 需要明确的验证命令。

bash
# Phase 0 完成度检查
make verify-phase-0
# 输出:
# ✅ pyproject.toml 存在且依赖已锁定
# ✅ Docker Compose 全栈可启动
# ✅ CI Pipeline 硬门禁已配置
# ✅ 4 个 guard 脚本可执行
# ✅ delivery/manifest.yaml 骨架存在
# ❌ PR 模板未创建 → 运行 make scaffold-pr-template
# 
# Phase 0 完成度: 5/6 (83%)
# Phase 1 完成度检查
make verify-phase-1
# ✅ organizations 表已创建
# ✅ RLS 策略已启用
# ✅ OrgContext 中间件已注入
# ✅ 隔离测试存在且全 PASS
# ❌ 审计日志表未创建
#
# Phase 1 完成度: 4/5 (80%)
不需要增强的部分
内容	原因
规则本身	规则是对的，不需要降低标准
Phase 划分	纵向切片顺序合理
测试分层	风险分级策略正确
Delivery SSOT	Schema 先行策略正确
开发十诫	保留，作为意识层面的指引
总结
增强项	为什么需要	成本
Pattern 文件强制注入 AI 上下文	让 AI 生成的代码天然合规	低（写一次复用无限次）
脚手架生成器	避免从零创建遗漏安全关键代码	中（Phase 0 投入，后续节省大量时间）
红线规则后果说明	让 Vibe Coder 理解"为什么不能跳过"	极低（每条规则加 2 行）
CI 错误人话化	Vibe Coder 能自助修复，不用找人问	低（在 guard 脚本里加 echo）
Phase 验证命令	明确"做完了没有"的判定	中（写验证脚本）
一句话：规范不降级，但把执行方式从"靠人理解"变成"靠 AI 约束 + 工具链护栏 + CI 兜底"。 Vibe Coder 的护栏不是更厚的文档，是更聪明的工具。




